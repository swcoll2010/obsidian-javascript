/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DATAVIEW_PLACEHOLDER_VALUE = null;
    exports.DATAVIEW_PLACEHOLDER_VALUE = DATAVIEW_PLACEHOLDER_VALUE;
  }
});

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({
  "node_modules/before-after-hook/lib/register.js"(exports, module2) {
    module2.exports = register;
    function register(state, name, method, options) {
      if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!options) {
        options = {};
      }
      if (Array.isArray(name)) {
        return name.reverse().reduce(function(callback, name2) {
          return register.bind(null, state, name2, callback, options);
        }, method)();
      }
      return Promise.resolve().then(function() {
        if (!state.registry[name]) {
          return method(options);
        }
        return state.registry[name].reduce(function(method2, registered) {
          return registered.hook.bind(null, method2, options);
        }, method)();
      });
    }
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({
  "node_modules/before-after-hook/lib/add.js"(exports, module2) {
    module2.exports = addHook;
    function addHook(state, kind, name, hook2) {
      var orig = hook2;
      if (!state.registry[name]) {
        state.registry[name] = [];
      }
      if (kind === "before") {
        hook2 = function(method, options) {
          return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
      }
      if (kind === "after") {
        hook2 = function(method, options) {
          var result;
          return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
            result = result_;
            return orig(result, options);
          }).then(function() {
            return result;
          });
        };
      }
      if (kind === "error") {
        hook2 = function(method, options) {
          return Promise.resolve().then(method.bind(null, options)).catch(function(error2) {
            return orig(error2, options);
          });
        };
      }
      state.registry[name].push({
        hook: hook2,
        orig
      });
    }
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({
  "node_modules/before-after-hook/lib/remove.js"(exports, module2) {
    module2.exports = removeHook;
    function removeHook(state, name, method) {
      if (!state.registry[name]) {
        return;
      }
      var index = state.registry[name].map(function(registered) {
        return registered.orig;
      }).indexOf(method);
      if (index === -1) {
        return;
      }
      state.registry[name].splice(index, 1);
    }
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({
  "node_modules/before-after-hook/index.js"(exports, module2) {
    var register = require_register();
    var addHook = require_add();
    var removeHook = require_remove();
    var bind = Function.bind;
    var bindable = bind.bind(bind);
    function bindApi(hook2, state, name) {
      var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
      hook2.api = { remove: removeHookRef };
      hook2.remove = removeHookRef;
      ["before", "error", "after", "wrap"].forEach(function(kind) {
        var args = name ? [state, kind, name] : [state, kind];
        hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
      });
    }
    function HookSingular() {
      var singularHookName = "h";
      var singularHookState = {
        registry: {}
      };
      var singularHook = register.bind(null, singularHookState, singularHookName);
      bindApi(singularHook, singularHookState, singularHookName);
      return singularHook;
    }
    function HookCollection() {
      var state = {
        registry: {}
      };
      var hook2 = register.bind(null, state);
      bindApi(hook2, state);
      return hook2;
    }
    var collectionHookDeprecationMessageDisplayed = false;
    function Hook() {
      if (!collectionHookDeprecationMessageDisplayed) {
        console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
        collectionHookDeprecationMessageDisplayed = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.Singular = Hook.Singular;
    module2.exports.Collection = Hook.Collection;
  }
});

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports, module2) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var global = getGlobal();
    module2.exports = exports = global.fetch;
    if (global.fetch) {
      exports.default = global.fetch.bind(global);
    }
    exports.Headers = global.Headers;
    exports.Request = global.Request;
    exports.Response = global.Response;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once2);
    module2.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// plugin/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GithubPublisher
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// plugin/settings.ts
var import_obsidian2 = require("obsidian");

// plugin/i18n/index.ts
var import_obsidian = require("obsidian");

// plugin/i18n/locales/en.ts
var en_default = {
  commands: {
    shareActiveFile: "Share active file",
    publisherDeleteClean: "Remove unshared and deleted file in repository",
    uploadAllNotes: "Upload all shared notes",
    uploadNewNotes: "Upload new shared notes",
    uploadAllNewEditedNote: "Upload all new and edited note since last upload",
    uploadAllEditedNote: "Upload all edited note since last upload",
    shareViewFiles: (viewFile) => `Share "${viewFile}" with Github Publisher`
  },
  deletion: {
    errorDeleteDefaultFolder: "You need a default folder name in the settings to use this command.",
    errorDeleteRootFolder: "You need to configure a root folder in the settings to use this command.",
    successDeleting: (nb) => `Successfully deleted ${nb} files.`,
    failedDeleting: (nb) => `Failed to delete ${nb} files.`,
    noFileDeleted: "No files have been deleted."
  },
  settings: {
    github: {
      githubConfiguration: "Github Configuration",
      repoName: "Repo Name",
      repoNameDesc: "The name of the repository where you store your blog.",
      mkdocsTemplate: "mkdocs-template",
      githubUsername: "Github Username",
      githubUsernameDesc: "Your github username.",
      ghTokenDesc: "A github token with repository permission. You can generate it ",
      here: "here.",
      githubToken: "Github Token",
      githubBranchHeading: "Main branch",
      githubBranchDesc: 'If you use a different main branch than "main", you can specify it here.',
      automaticallyMergePR: "Automatically merge pull requests"
    },
    uploadConfig: {
      uploadConfig: "Upload configuration",
      pathSetting: "Path settings",
      folderBehavior: "Folder behavior",
      folderBehaviorDesc: "Choose between a fixed folder, the value of a frontmatter key or your obsidian relative path.",
      fixedFolder: "Fixed Folder",
      yaml: "YAML frontmatter",
      obsidianPath: "Obsidian Path",
      defaultFolder: "Default Folder",
      defaultFolderDesc: "Set the default reception folder",
      defaultFolderPlaceholder: "docs",
      pathRemoving: "Path removing",
      pathRemovingDesc: "Allow to publish only subfolder by removing the path before that :",
      pathRemovingPlaceholder: "GardenSketch",
      frontmatterKey: "Frontmatter key",
      frontmatterKeyDesc: "Set the key where to get the value of the folder",
      frontmatterKeyPlaceholder: "category",
      rootFolder: "Root folder",
      rootFolderDesc: "Append this path to the folder set by the frontmatter key.",
      useFrontmatterTitle: "Set the title from the frontmatter",
      useFrontmatterTitleDesc: 'Use a frontmatter value to generate the filename. By default, "title" is used.'
    },
    textConversion: {
      textConversion: "Content's conversion",
      textConversionDesc: "Theses option won't change the content of the file in your Obsidian Vault, but will change the content of the file in Github.",
      textHeader: "Text",
      hardBreakTitle: "Markdown hard line break",
      hardBreakDesc: 'Add a markdown hard line break (double whitespace) after each line. This settings can be overridden by the frontmatter key "hardbreak".',
      links: {
        header: "Links",
        desc: 'You can prevent links to be converted and keep the alt text (or filename) by using the frontmatter key "links" with the value "false".',
        internals: "Internals Links",
        internalsDesc: "Convert the internal link in shared file to match the folder settings",
        wikilinks: "[[Wikilinks]]",
        wikilinksDesc: 'Convert Wikilinks to MDlinks, without changing the contents. This option can be overridden by the frontmatter key "mdlinks".',
        folderNote: "Folder note",
        folderNoteDesc: 'Rename files to "index.md" if it has the same name as their parent folder/category (also works if the note is out of the folder).'
      },
      censor: {
        TextHeader: "Text replacer",
        TextDesc: "Replace text (or regex) in the file with the given value.",
        TextFlags: "Flags (based on JS regex and can be combined) :",
        flags: {
          insensitive: "i : Insensitive.",
          global: "g : Global",
          multiline: "m : Multiline",
          dotAll: "s : DotAll",
          unicode: "u : Unicode",
          sticky: "y : Sticky",
          error: (flag) => `The flag "${flag}" is not valid.`
        },
        TextEmpty: "Replacement can be empty to remove the whole string.",
        ToolTipAdd: "Add a new text replacer",
        ToolTipRemove: "Delete this text replacer",
        PlaceHolder: "Regex or text to replace",
        ValuePlaceHolder: "Replacement value",
        Before: "Run it before the other plugin conversion (link, dataview, etc.)",
        After: "Run it after the other plugin conversion (link, dataview, etc.)"
      },
      dataview: {
        header: "Dataview",
        desc: 'Convert dataview to markdown. This settings can be overridden by the frontmatter key "dataview".'
      },
      tags: {
        header: "Convert frontmatter/dataview field into tags",
        desc: "This will convert any frontmatter or dataview inline field into frontmatter tags. Separate fields with a comma.",
        ExcludeHeader: "Exclude value from conversion",
        ExcludeDesc: "This will exclude value from being converted. Separate fields with a comma.",
        inlineTagsHeader: "Inline tags",
        inlineTagsDesc: 'Add your inline tags in your frontmatter tags field and converting nested tags with replacing "/" with "_"'
      }
    },
    embed: {
      embed: "Embed",
      transferImage: "Transfer attachments",
      transferImageDesc: 'Send attachments embedded in a file to github. This option can be overridden by the frontmatter key "attachment".',
      transferEmbeddedNotes: "Transfer embedded notes",
      transferEmbeddedNotesDesc: 'Send embedded notes in a shared file to github. Only shared files will be send! This option can be overridden by the frontmatter key "embed".',
      defaultImageFolder: "Default attachment folder",
      defaultImageFolderDesc: "To use a folder different from default",
      transferMetaFile: "Send files using a metadata field",
      transferMetaFileDesc: "Set the names of the metadata field you want to use to send files. Separate fields with a comma. Dataview inline field are supported."
    },
    githubWorkflow: {
      githubActionName: "Github action name",
      githubActionNameDesc: "If you want to activate a github action when the plugin push the file, set the name of the file (in your .github/worfklows folder).",
      autoCleanUp: "Auto clean up",
      autoCleanUpDesc: "If the plugin must remove from github the removed files (stop share or deleted)",
      excludedFiles: "Excluded files",
      excludedFilesDesc: "If you want to exclude some folder from the auto clean up, set their path."
    },
    plugin: {
      pluginSettings: "Plugin Settings",
      shareKey: "Share Key",
      shareKeyDesc: "The frontmatter key to publish your file on the website.",
      excludedFolder: "Excluded Folder",
      excludedFolderDesc: "Never publish file in these folder, regardless of the share key. Separate folder name by comma.",
      fileMenu: "File Menu",
      fileMenuDesc: "Add an sharing commands in the file menu",
      editorMenu: "Editor Menu",
      editorMenuDesc: "Add a sharing commands in the right-click menu",
      copyLink: {
        copylinkSetting: "Copy link",
        copylinkDesc: "Send a link to your note in your clipboard",
        baselink: "Blog link",
        baselinkDesc: "Create the clipboard link with this base. By default : https://username.github.io/repo/",
        linkpathremover: "Remove link part",
        linkpathremoverDesc: "Remove this part from the created links. Separate by comma if multiple value must be removed."
      },
      logNoticeHeader: "Notice every error",
      logNoticeDesc: "On mobile, it can be hard to debug the plugin. Enable this option to log every error in a Notice.",
      shareExternalModifiedTitle: "Share external modified file",
      shareExternalModifiedDesc: "Send edited file if they are different from the active file. Useful when editing metadata using MetaEdit or Metadata Menu."
    },
    help: {
      help: "Help",
      usefulLinks: {
        title: "Useful links",
        documentation: "Documentation",
        repository: "Repository",
        issue: "Issue",
        discussion: "Discussion",
        links: "https://obsidian-publisher.netlify.app/"
      },
      frontmatter: {
        title: "Frontmatter keys cheatsheet",
        desc: "Moreover, there are some frontmatter YAML keys that can be usefull for your workflow. The YAML code below show the default settings, but feel free to change it to your needs in each notes!",
        share: "This key is used to share a note with the plugin.",
        mdlinks: "convert all wikilinks to markdown links",
        convert: {
          enableOrDisable: "enable or disable the conversion of links. Disabling this will remove the",
          or: "or",
          syntax: "syntax, while keeping the file name or the alias."
        },
        embed: {
          send: "send embedded note to GitHub",
          remove: "remove the embed from the note, leaving empty line."
        },
        attachment: {
          send: "send all attachments to github",
          folder: "change the default folder for the attachments"
        },
        dataview: "convert dataview queries to markdown.",
        hardBreak: "convert all linebreaks to markdown \xABhard break\xBB.",
        repo: {
          desc: "change the default repo for the note.",
          owner: "owner of the repo",
          repo: "name of the repo",
          branch: "branch of the repo"
        },
        titleKey: "change the title of the note.",
        autoclean: "disable or enable autocleaning",
        baselink: "change the base link for the copy link command"
      },
      multiRepoHelp: {
        title: "Send to multiple repository",
        desc: "If you want to send your notes to multiple repository, you can use the ",
        desc2: "key in your frontmatter. The value of this key must be a list of repository. Each repository must have the following keys ",
        exampleDesc: "The YAML code below show an example based on your settings."
      }
    }
  },
  informations: {
    startingClean: (repoInfo) => `Starting cleaning ${repoInfo}`,
    scanningRepo: "Scanning the repository, may take a while...",
    foundNoteToSend: (noteLength) => `Found ${noteLength} new notes to send`,
    noNewNote: "No new notes to share.",
    successfullPublish: (noticeValue) => `Successfully published ${noticeValue[0]} to ${noticeValue[1]}.`,
    waitingWorkflow: "Now, waiting for the workflow to be completed...",
    sendMessage: (noticeValue) => `Send ${noticeValue[0]} to ${noticeValue[1]}${noticeValue[2]}`
  },
  error: {
    unablePublishNote: (fileInfo) => `Unable to publish note ${fileInfo}\uFF0Cskipping it`,
    errorPublish: (repoInfo) => `Error publishing to ${repoInfo}.`,
    unablePublishMultiNotes: "Unable to publish multiple notes, something went wrong.",
    mergeconflic: `Pull-request is not mergeable, you need to do it manually.`,
    errorConfig: (repoInfo) => `Error configuring ${repoInfo}. Please check your settings.`
  }
};

// plugin/i18n/locales/fr.ts
var fr_default = {
  commands: {
    shareActiveFile: "Partager le fichier actif",
    publisherDeleteClean: "Suppression des fichiers non partag\xE9s et/ou supprim\xE9 du d\xE9p\xF4t ",
    uploadAllNotes: "Publier toutes les notes partag\xE9es",
    uploadNewNotes: "Publier les nouvelles notes",
    uploadAllNewEditedNote: "Publier toutes les notes nouvelles et modifi\xE9es depuis le dernier envoi.",
    uploadAllEditedNote: "Publier toutes les notes \xE9dit\xE9es depuis le dernier envoie",
    shareViewFiles: (viewFile) => `Partager "${viewFile}" avec Github Publisher`
  },
  deletion: {
    errorDeleteDefaultFolder: "Vous avez besoin d'un dossier par d\xE9faut dans les param\xE8tres pour utiliser cette commande.",
    errorDeleteRootFolder: "Vous devez configurer un dossier racine dans les param\xE8tres pour utiliser cette commande.",
    successDeleting: (nb) => `Suppression r\xE9ussie de ${nb} fichiers.`,
    failedDeleting: (nb) => `\xC9chec de la suppression de ${nb} files.`,
    noFileDeleted: "Aucun fichier n'a \xE9t\xE9 supprim\xE9"
  },
  settings: {
    github: {
      githubConfiguration: "Configuration GitHub",
      repoName: "Nom du d\xE9p\xF4t",
      repoNameDesc: "Le nom du d\xE9p\xF4t dans lequel vous enregistrez votre blog.",
      mkdocsTemplate: "mkdocs-template",
      githubUsername: "Nom d'utilisateur GitHub",
      githubUsernameDesc: "Votre nom d'utilisateur GitHub.",
      ghTokenDesc: "Un token GitHub avec autorisation de d\xE9p\xF4t. Vous pouvez le g\xE9n\xE9rer ",
      here: "ici.",
      githubToken: "Token GitHub",
      githubBranchHeading: "Branche principale",
      githubBranchDesc: "Si vous utilisez une branche principale diff\xE9rente de main, vous pouvez la sp\xE9cifier ici.",
      automaticallyMergePR: "Fusionner automatiquement les pull requests"
    },
    uploadConfig: {
      uploadConfig: "Configuration d'upload",
      pathSetting: "Param\xE8tres du chemin d'acc\xE8s",
      folderBehavior: "Comportement du dossier",
      folderBehaviorDesc: "Choisissez entre un dossier fixe, la valeur d'une cl\xE9 de m\xE9tadonn\xE9e ou votre chemin relatif dans Obsidian.",
      fixedFolder: "Dossier fix\xE9",
      yaml: "Cl\xE9 de m\xE9tadonn\xE9e",
      obsidianPath: "Chemin Obsidian",
      defaultFolder: "Dossier par d\xE9faut",
      defaultFolderDesc: "D\xE9finir le dossier de r\xE9ception par d\xE9faut.",
      defaultFolderPlaceholder: "docs",
      pathRemoving: "Suppression de chemin",
      pathRemovingDesc: "Permettre de publier uniquement le sous-dossier en supprimant le chemin avant celui-ci :",
      pathRemovingPlaceholder: "Blog",
      frontmatterKey: "Cl\xE9 de m\xE9tadonn\xE9es",
      frontmatterKeyDesc: "D\xE9finir la cl\xE9 o\xF9 obtenir la valeur du dossier.",
      frontmatterKeyPlaceholder: "cat\xE9gorie",
      rootFolder: "Dossier racine",
      rootFolderDesc: "Ajoutez ce chemin au dossier d\xE9fini par la cl\xE9 de m\xE9tadonn\xE9es.",
      useFrontmatterTitle: "Utiliser une cl\xE9 de m\xE9tadonn\xE9es pour le titre",
      useFrontmatterTitleDesc: 'Utilisez un champ du frontmatter pour g\xE9n\xE9rer le nom du fichier. Par d\xE9faut "title" est utilis\xE9.'
    },
    textConversion: {
      textConversion: "Conversion du contenu",
      textConversionDesc: "Ces options ne changent pas le contenu du fichier dans votre coffre Obsidian, mais changeront le contenu du fichier publi\xE9 sur GitHub.",
      textHeader: "Texte",
      hardBreakTitle: "Saut de ligne strict",
      hardBreakDesc: 'Ajoutez un retour \xE0 la ligne Markdown (double espace) apr\xE8s chaque ligne. Ce param\xE8tre peut \xEAtre outrepass\xE9 par la cl\xE9 de m\xE9tadonn\xE9es "hardbreak".',
      links: {
        header: "Liens",
        desc: 'Vous pouvez emp\xEAcher la conversion des liens et conserver le texte alt (ou le nom du fichier) en utilisant la cl\xE9 frontmatter "links" avec la valeur "false".',
        internals: "Liens internes",
        internalsDesc: "Convertir le lien interne dans le fichier partag\xE9 pour qu'il corresponde aux param\xE8tres du dossier.",
        wikilinks: "Wikilinks",
        wikilinksDesc: 'Convertir les liens Wikilinks en liens markdown, sans en modifier le contenu. Ce param\xE8tre peut \xEAtre outrepass\xE9 par la cl\xE9 de m\xE9tadonn\xE9es "mdlinks".',
        folderNote: "Folder Note",
        folderNoteDesc: `Renommer les fichiers en "index.md" s'il porte le m\xEAme nom que leur dossier/cat\xE9gorie parent (fonctionne aussi si la note est \xE0 l'ext\xE9rieur du dossier).`
      },
      censor: {
        TextHeader: "Replacement de texte",
        TextDesc: "Replacement de texte (ou regex) par un autre texte.",
        TextFlags: "Flags (bas\xE9 sur les regex JS et pouvant \xEAtre combin\xE9) :",
        flags: {
          insensitive: "i : Insensible \xE0 la casse.",
          global: "g : Globale",
          multiline: "m : Multi-ligne",
          dotAll: "s : Dot-all",
          unicode: "u : Unicode",
          sticky: "y : Sticky",
          error: (flag) => `Le flag "${flag}" est invalide.`
        },
        TextEmpty: "Le remplacement de texte peut \xEAtre vide afin de supprimer le texte.",
        ToolTipAdd: "Ajouter un nouveau remplacement",
        ToolTipRemove: "Supprimer ce remplacement",
        PlaceHolder: "Regex ou text \xE0 remplacer",
        ValuePlaceHolder: "Remplacement",
        Before: "Ex\xE9cut\xE9 avant les autres conversions (liens, dataview, etc.)",
        After: "Ex\xE9cut\xE9 apr\xE8s les autres conversions (liens, dataview, etc.)"
      },
      dataview: {
        header: "Dataview",
        desc: 'Convertir dataview en markdown. Ce param\xE8tre peut \xEAtre outrepass\xE9 par la cl\xE9 de m\xE9tadonn\xE9es "dataview".'
      },
      tags: {
        inlineTagsHeader: "Inlines tags",
        inlineTagsDesc: 'Ajoute vos tags inline dans votre bloc de m\xE9tadonn\xE9e et convertit les tags imbriqu\xE9s en rempla\xE7ant "/" par "_".',
        header: "Conversion des champs du frontmatter/dataview en tags",
        desc: "Ceci convertira tous les champs du frontmatter/dataview en tags. S\xE9parez les champs par une virgule.",
        ExcludeHeader: "Exclure des valeurs de la conversion",
        ExcludeDesc: "Exclure la valeur de la conversion. S\xE9parez les valeurs par une virgule."
      }
    },
    embed: {
      embed: "Transclusion",
      transferImage: "Transf\xE9rer les pi\xE8ces jointes",
      transferImageDesc: 'Envoyer les pi\xE8ces-jointes int\xE9gr\xE9es dans un fichier dans le d\xE9p\xF4t. Ce param\xE8tre peut \xEAtre outrepass\xE9 par la cl\xE9 de m\xE9tadonn\xE9es "attachment".',
      transferEmbeddedNotes: "Transf\xE9rer les notes transclues",
      transferEmbeddedNotesDesc: 'Envoyez des notes transcluent dans un fichier partag\xE9 dans le d\xE9p\xF4t. Seuls les fichiers partag\xE9s seront envoy\xE9s ! Ce param\xE8tre peut \xEAtre outrepass\xE9 par la cl\xE9 de m\xE9tadonn\xE9es "embed".',
      defaultImageFolder: "Dossier de pi\xE8ces-jointes par d\xE9faut",
      defaultImageFolderDesc: "Pour utiliser un dossier diff\xE9rent de celui par d\xE9faut pour les pi\xE8ces-jointes.",
      transferMetaFile: "Envoyer des fichiers en utilisant une cl\xE9 de m\xE9tadonn\xE9e",
      transferMetaFileDesc: "Mettez les noms des champs de m\xE9tadonn\xE9es que vous voulez utiliser pour envoyer les fichiers. S\xE9parez les champs par une virgule. Les champs Dataview sont pris en charge."
    },
    githubWorkflow: {
      githubActionName: "Nom de l'action GitHub",
      githubActionNameDesc: 'Si vous souhaitez activer une action github lorsque le plugin push le fichier, indiquez le nom du fichier (dans votre dossier ".github/worfklows").',
      autoCleanUp: "Auto-nettoyage",
      autoCleanUpDesc: "Si le plugin doit retirer de votre d\xE9p\xF4t les fichiers supprim\xE9s (arr\xEAt de partage ou supprim\xE9).",
      excludedFiles: "Fichier exclus",
      excludedFilesDesc: "Si vous voulez exclure certains dossiers du nettoyage automatique, d\xE9finissez leur chemin."
    },
    plugin: {
      pluginSettings: "Param\xE8tres du plugin",
      shareKey: "Cl\xE9 de partage",
      shareKeyDesc: "La cl\xE9 de m\xE9tadonn\xE9es pour publier votre fichier sur le d\xE9p\xF4t.",
      excludedFolder: "Dossier exclus",
      excludedFolderDesc: "Les fichiers dans ses dossiers ne seront jamais publi\xE9s, quelle que soit l'\xE9tat de la cl\xE9 de partage. S\xE9parez les noms de dossier par une virgule.",
      fileMenu: 'Menu "Fichier"',
      fileMenuDesc: 'Ajouter une commande de partage dans le menu "Fichier"',
      editorMenu: 'Menu "Edition"',
      editorMenuDesc: "Ajouter une commande de partage dans le menu du clic droit.",
      copyLink: {
        copylinkSetting: "Copie de lien.",
        copylinkDesc: "Envoyer un lien vers votre note dans votre presse-papier.",
        baselink: "Lien du blog",
        baselinkDesc: "Cr\xE9er le lien du presse-papiers avec cette base. Par d\xE9faut : https://username.github.io/repo/.",
        linkpathremover: "Retirer une partie du lien",
        linkpathremoverDesc: "Supprimer cette partie des liens cr\xE9\xE9s. S\xE9parer par une virgule si plusieurs valeurs doivent \xEAtre supprim\xE9es."
      },
      logNoticeHeader: "Notifier toutes les erreurs",
      logNoticeDesc: "Sur mobile, il peut \xEAtre difficile de debug le module. Activer cette option pour notifier toutes les erreurs via une notification Obsidian.",
      shareExternalModifiedTitle: "Partager les fichiers modifi\xE9s externes",
      shareExternalModifiedDesc: "Envoyer les fichiers modifi\xE9s s'ils sont diff\xE9rents du fichier actif. Utile si vous modifier les m\xE9tadonn\xE9es \xE0 l'aide de Metadata Menu ou MetaEdit."
    },
    help: {
      help: "Aide",
      usefulLinks: {
        title: "Liens utiles",
        documentation: "Documentation",
        repository: "D\xE9p\xF4t",
        issue: "Issue",
        discussion: "Discussion",
        links: "https://obsidian-publisher.netlify.app/fr"
      },
      frontmatter: {
        title: "Aide m\xE9moire frontmatter",
        desc: "Il existe quelque cl\xE9s YAML qui peuvent vous \xEAtre utile. Le code ci-dessous montre les param\xE8tres par d\xE9faut, mais n'h\xE9sitez pas \xE0 le modifier selon vos besoins pour chaque note !",
        share: "Permet de partager une note.",
        mdlinks: "Convertit tous les wikilinks en liens markdowns",
        convert: {
          enableOrDisable: "active ou d\xE9sactive la conversion des liens. En d\xE9sactivant cette option, vous supprimez les",
          or: "ou",
          syntax: "syntaxes, tout en gardant le nom du fichier ou son alias."
        },
        embed: {
          send: "envoie les notes transclues du fichier partag\xE9 dans le d\xE9p\xF4t. Seuls les fichiers partag\xE9s seront envoy\xE9s !",
          remove: "Supprime les notes transclues du fichier partag\xE9, en ne laissant qu'une ligne vide."
        },
        attachment: {
          send: "envoie toutes les pi\xE8ces jointes dans le d\xE9p\xF4t Git.",
          folder: "change le dossier par d\xE9faut pour les pi\xE8ces jointes."
        },
        dataview: "convertit les queries dataview en markdown.",
        hardBreak: "convertit tous les sauts de ligne en \xABhard break\xBB markdown.",
        repo: {
          desc: "changer le d\xE9p\xF4t GitHub pour cette note.",
          owner: "pseudo du propri\xE9taire du d\xE9p\xF4t",
          repo: "nom du d\xE9p\xF4t",
          branch: "nom de la branche"
        },
        titleKey: "change le titre de la note.",
        autoclean: "d\xE9sactive ou active le nettoyage automatique.",
        baselink: "change le lien de base pour la commande de copie de lien."
      },
      multiRepoHelp: {
        title: "Envoie dans plusieurs d\xE9p\xF4ts",
        desc: "Si vous souhaitez envoyer vos notes dans plusieurs d\xE9p\xF4t en m\xEAme temps, vous pouvez utiliser la cl\xE9 ",
        desc2: "dans votre frontmatter. La valeur de cette cl\xE9 doit \xEAtre une liste. Chaque d\xE9p\xF4t doit avoir les cl\xE9s suivantes ",
        exampleDesc: "Le code YAML ci-dessous montre un exemple bas\xE9 sur vos param\xE8tres."
      }
    }
  },
  informations: {
    startingClean: (repoInfo) => `D\xE9but du nettoyage ${repoInfo}...`,
    scanningRepo: "Scan du d\xE9p\xF4t, cela peut prendre un moment...",
    foundNoteToSend: (noteLength) => `Trouv\xE9 ${noteLength} nouvelles notes \xE0 envoyer !`,
    noNewNote: "Aucune nouvelle note \xE0 partager.",
    successfullPublish: (noticeValue) => `Publication r\xE9ussie de ${noticeValue[0]} vers ${noticeValue[1]}.`,
    waitingWorkflow: "Maintenant, attente de la compl\xE9tion du workflow...",
    sendMessage: (noticeValue) => `Envoi de ${noticeValue[0]} \xE0 ${noticeValue[1]}${noticeValue[2]}.`
  },
  error: {
    unablePublishNote: (fileInfo) => `Impossible de publier la note ${fileInfo}, ignor\xE9e.`,
    errorPublish: (repoInfo) => `Erreur lors de la publication sur ${repoInfo}.`,
    unablePublishMultiNotes: "Impossible de publier plusieurs notes, quelque chose s'est mal pass\xE9.",
    mergeconflic: `La pull-request n'est pas fusionnable, vous avez besoin de le faire manuellement.`,
    errorConfig: (repoInfo) => `Erreur de configuration pour ${repoInfo}. Merci de v\xE9rifier vos param\xE8tres.`
  }
};

// plugin/i18n/locales/ru.ts
var ru_default = {
  commands: {
    shareActiveFile: "\u041F\u043E\u0434\u0435\u043B\u0438\u0442\u044C\u0441\u044F \u0442\u0435\u043A\u0443\u0449\u0438\u043C \u0444\u0430\u0439\u043B\u043E\u043C",
    publisherDeleteClean: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0431\u043E\u043B\u044C\u0448\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0435 \u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u044B \u0438\u0437 \u0440\u0435\u043F\u043E\u0437\u0438\u0442\u043E\u0440\u0438\u044F",
    uploadAllNotes: "\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u0432\u0441\u0435 \u043E\u0431\u0449\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
    uploadNewNotes: "\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u043D\u043E\u0432\u044B\u0435 \u043E\u0431\u0449\u0438\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
    uploadAllNewEditedNote: "\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u0432\u0441\u0435 \u043D\u043E\u044B\u0435 \u0438 \u043E\u0442\u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0435\u0439 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438",
    uploadAllEditedNote: "\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u0432\u0441\u0435 \u043E\u0442\u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0441 \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0435\u0439 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438",
    shareViewFiles: (viewFile) => `\u041F\u043E\u0434\u0435\u043B\u0438\u0442\u044C\u0441\u044F "${viewFile}" \u0441 Github Publisher`
  },
  deletion: {
    errorDeleteDefaultFolder: "\u0412\u044B \u0434\u043E\u043B\u0436\u043D\u044B \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u043F\u0430\u043F\u043A\u0438 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445, \u0447\u0442\u043E\u0431\u044B \u0432\u043E\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u044D\u0442\u043E\u0439 \u043A\u043E\u043C\u0430\u043D\u0434\u043E\u0439.",
    errorDeleteRootFolder: "\u0412\u044B \u0434\u043E\u043B\u0436\u043D\u044B \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u043A\u043E\u0440\u043D\u0435\u0432\u0443\u044E \u043F\u0430\u043F\u043A\u0443 \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445, \u0447\u0442\u043E\u0431\u044B \u0432\u043E\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u044D\u0442\u043E\u0439 \u043A\u043E\u043C\u0430\u043D\u0434\u043E\u0439.",
    successDeleting: (nb) => `\u0423\u0441\u043F\u0435\u0448\u043D\u043E \u0443\u0434\u0430\u043B\u0435\u043D\u043E ${nb} \u0444\u0430\u0439\u043B\u043E\u0432.`,
    failedDeleting: (nb) => `\u041D\u0435\u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0443\u0434\u0430\u043B\u0438\u0442\u044C ${nb} \u0444\u0430\u0439\u043B\u043E\u0432.`,
    noFileDeleted: "\u0424\u0430\u0439\u043B\u044B \u043D\u0435 \u0431\u044B\u043B\u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u044B."
  },
  settings: {
    github: {
      githubConfiguration: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0438\u043D\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u0438 \u0441 Github",
      repoName: "Repo Name",
      repoNameDesc: "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0440\u0435\u043F\u043E\u0437\u0438\u0442\u043E\u0440\u0438\u044F \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u043C \u0431\u0443\u0434\u0435\u0442 \u0445\u0440\u0430\u043D\u0438\u0442\u044C\u0441\u044F \u0431\u043B\u043E\u0433.",
      mkdocsTemplate: "mkdocs-template",
      githubUsername: "Github Username",
      githubUsernameDesc: "\u0412\u0430\u0448\u0435 \u0438\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F github.",
      ghTokenDesc: "Github token \u0441 \u043F\u0440\u0430\u0432\u0430\u043C\u0438 \u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F \u043A \u0440\u0435\u043F\u043E\u0437\u0438\u0442\u043E\u0440\u0438\u044E. \u0412\u044B \u043C\u043E\u0436\u0435\u0442\u0435 \u0441\u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0435\u0433\u043E ",
      here: "\u0437\u0434\u0435\u0441\u044C.",
      githubToken: "Github Token",
      githubBranchHeading: "Main branch",
      githubBranchDesc: 'If you use a different main branch than "main", you can specify it here.',
      automaticallyMergePR: "Automatically merge PR"
    },
    uploadConfig: {
      uploadConfig: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438",
      pathSetting: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u0443\u0442\u0435\u0439",
      folderBehavior: "\u041F\u043E\u0432\u0435\u0434\u0435\u043D\u0438\u0435 \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u043F\u0430\u043F\u043E\u043A",
      folderBehaviorDesc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043C\u0435\u0436\u0434\u0443 \u0444\u0438\u043A\u0441\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u043E\u0439 \u043F\u0430\u043F\u043A\u043E\u0439, \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435\u043C \u0438\u0437 Frontmatter \u0438\u043B\u0438 \u043F\u0443\u0442\u0435\u043C \u043E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430 obsidian",
      fixedFolder: "\u0424\u0438\u043A\u0441\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u0430\u044F \u043F\u0430\u043F\u043A\u0430",
      yaml: "YAML frontmatter",
      obsidianPath: "\u041E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430 Obsidian",
      defaultFolder: "\u041F\u0430\u043F\u043A\u0430 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
      defaultFolderDesc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u043F\u0430\u043F\u043A\u0443 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E \u0434\u043B\u044F \u043F\u0443\u0431\u043B\u0438\u043A\u0430\u0446\u0438\u0438",
      defaultFolderPlaceholder: "docs",
      pathRemoving: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0438\u0437 \u043F\u0443\u0442\u0438",
      pathRemovingDesc: "\u0420\u0430\u0437\u0440\u0435\u0448\u0430\u0442\u044C \u043F\u0443\u0431\u043B\u0438\u043A\u0430\u0446\u0438\u044E \u0442\u043E\u043B\u044C\u043A\u043E \u043F\u043E\u0434\u043F\u0430\u043F\u043E\u043A \u0443\u0434\u0430\u043B\u044F\u044F \u0438\u0437 \u043F\u0443\u0442\u0438 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E \u0441\u0442\u0440\u043E\u043A\u0443 :",
      pathRemovingPlaceholder: "GardenSketch",
      frontmatterKey: "Frontmatter \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E",
      frontmatterKeyDesc: "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u043C \u0431\u0443\u0434\u0435\u0442 \u0443\u043A\u0430\u0437\u0430\u043D\u0430 \u043F\u0430\u043F\u043A\u0430",
      frontmatterKeyPlaceholder: "category",
      rootFolder: "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430",
      rootFolderDesc: "\u0414\u043E\u0431\u0430\u0432\u043B\u044F\u0442\u044C \u044D\u0442\u0443\u0442 \u043F\u0430\u043F\u043A\u0443 \u043A \u043F\u0443\u0442\u044F\u043C \u0437\u0430\u0434\u0430\u043D\u043D\u044B\u043C \u0447\u0435\u0440\u0435\u0437 \u0441\u0432\u043E\u0439\u0441\u0442\u0432\u043E frontmatter.",
      useFrontmatterTitle: "Set the title from the frontmatter",
      useFrontmatterTitleDesc: 'Use a frontmatter value to generate the filename. By default, "title" is used.'
    },
    textConversion: {
      textConversion: "\u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u0442\u0435\u043A\u0441\u0442\u0430",
      textConversionDesc: "Theses option won't change the content of the file in your Obsidian Vault, but will change the content of the file in Github.",
      textHeader: "\u0422\u0435\u043A\u0441\u0442",
      hardBreakTitle: "\u0416\u0435\u0441\u0442\u043A\u0438\u0435 \u043F\u0435\u0440\u0435\u043D\u043E\u0441\u044B \u0441\u0442\u0440\u043E\u043A \u0432 Markdown",
      hardBreakDesc: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0432\u0438\u0434\u0438\u043C\u044B\u0439 \u043F\u0435\u0440\u0435\u043D\u043E\u0441 \u0441\u0442\u0440\u043E\u043A\u0438 (\u0434\u0432\u043E\u0439\u043D\u043E\u0439 \u043F\u0435\u0440\u0435\u043D\u043E\u0441) \u0432 markdown \u043F\u043E\u0441\u043B\u0435 \u043A\u0430\u0436\u0434\u043E\u0439 \u0441\u0442\u0440\u043E\u043A\u0438.",
      links: {
        header: "\u0421\u0441\u044B\u043B\u043A\u0438",
        desc: 'You can prevent links to be converted and keep the alt text (or filename) by using the frontmatter key "links" with the value "false".',
        folderNote: "\u0418\u043D\u0434\u0435\u043A\u0441\u043D\u044B\u0439 \u0444\u0430\u0439\u043B \u0432 \u043F\u0430\u043F\u043A\u0435",
        folderNoteDesc: '\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u044B\u0432\u0430\u0442\u044C \u0444\u0430\u0439\u043B \u0432 "index.md" \u0432 \u0441\u043B\u0443\u0447\u0430\u0435 \u0435\u0441\u043B\u0438 \u043E\u043D \u043D\u0430\u0437\u044B\u0432\u0430\u0435\u0442\u0441\u044F \u0442\u0430\u043A\u0436\u0435 \u043A\u0430\u043A \u0440\u043E\u0434\u0438\u0442\u0435\u043B\u044C\u0441\u043A\u0430\u044F \u043F\u0430\u043F\u043A\u0430 (\u0440\u0430\u0431\u043E\u0442\u0430\u0435\u0442 \u0438 \u0432 \u0442\u043E\u043C \u0441\u043B\u0443\u0447\u0430\u0435 \u0435\u0441\u043B\u0438 \u0444\u0430\u0439\u043B \u0432\u043D\u0435 \u043F\u0430\u043F\u043A\u0438).',
        internals: "\u0412\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u0438\u0435 \u0441\u0441\u044B\u043B\u043A\u0438",
        internalsDesc: "\u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u044B\u0432\u0430\u0442\u044C \u0432\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u0438\u0435 \u0441\u0441\u044B\u043B\u043A\u0438 \u0432 \u043E\u0431\u0449\u0438\u0445 \u0444\u0430\u0439\u043B\u0430 \u0432 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0435 \u0441 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u043C\u0438 \u043F\u0430\u043F\u043A\u0438",
        wikilinks: "[[Wiki-\u0441\u0441\u044B\u043B\u043A\u0438]]",
        wikilinksDesc: "\u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u044B\u0432\u0430\u0442\u044C Wiki-\u0441\u0441\u044B\u043B\u043A\u0438 \u0432 MarkDown \u0441\u0441\u044B\u043B\u043A\u0438, \u043D\u0435 \u0442\u0440\u043E\u0433\u0430\u044F \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0435"
      },
      dataview: {
        header: "Dataview",
        desc: "\u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C dataview \u0432 markdown."
      },
      censor: {
        TextHeader: "Text replacer",
        TextDesc: "Replace text (or regex) in the file with the given value.",
        TextFlags: "Flags (based on JS regex and can be combined) :",
        flags: {
          insensitive: "i : Insensitive.",
          global: "g : Global",
          multiline: "m : Multiline",
          dotAll: "s : DotAll",
          unicode: "u : Unicode",
          sticky: "y : Sticky",
          error: (flag) => `The flag "${flag}" is not valid.`
        },
        TextEmpty: "Replacement can be empty to remove the whole string.",
        ToolTipAdd: "Add a new text replacer",
        ToolTipRemove: "Delete this text replacer",
        PlaceHolder: "Regex or text to replace",
        ValuePlaceHolder: "Replacement value",
        Before: "Run it before the other plugin conversion (link, dataview, etc.)",
        After: "Run it after the other plugin conversion (link, dataview, etc.)"
      },
      tags: {
        inlineTagsHeader: "Inline tags",
        inlineTagsDesc: 'Add your inline tags in your frontmatter tags field and converting nested tags with replacing "/" with "_"',
        header: "Convert frontmatter/dataview field to tags",
        desc: "This will convert any frontmatter or dataview inline field into frontmatter tags. Separate fields with a comma.",
        ExcludeHeader: "Exclude value from conversion",
        ExcludeDesc: "This will exclude value from being converted. Separate fields with a comma."
      }
    },
    embed: {
      embed: "\u0412\u0441\u0442\u0430\u0432\u043A\u0438",
      transferImage: "\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
      transferImageDesc: "\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u044F\u0442\u044C \u0432\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u044B\u0435 \u0432 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043D\u0430 github",
      transferEmbeddedNotes: "\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u044F\u0442\u044C \u0432\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438",
      transferEmbeddedNotesDesc: "\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u044F\u0442\u044C \u0432\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0438\u0437 \u043E\u0431\u0449\u0438\u0445 \u0444\u0430\u0439\u043B\u043E\u0432 \u043D\u0430 github. \u0422\u043E\u043B\u044C\u043A\u043E \u043E\u0431\u0449\u0438\u0435 \u0444\u0430\u0439\u043B\u044B \u0431\u0443\u0434\u0443\u0442 \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u044B!",
      defaultImageFolder: "\u041F\u0430\u043F\u043A\u0430 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E \u0434\u043B\u044F \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
      defaultImageFolderDesc: "\u0415\u0441\u043B\u0438 \u0432\u044B \u0445\u043E\u0442\u0438\u0442\u0435 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u043E\u0442\u043B\u0438\u0447\u043D\u0443\u044E \u043E\u0442 \u043F\u0430\u043F\u043A\u0438 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
      transferMetaFile: "Send files using a metadata field",
      transferMetaFileDesc: "Set the names of the metadata field you want to use to send files. Separate fields with a comma. Dataview inline field are supported."
    },
    githubWorkflow: {
      githubActionName: "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 Github action",
      githubActionNameDesc: "\u0415\u0441\u043B\u0438 \u0432\u044B \u0445\u043E\u0442\u0438\u0442\u0435 \u0430\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u0442\u044C github action \u043F\u043E\u0441\u043B\u0435 \u0442\u043E\u0433\u043E \u043A\u0430\u043A \u043F\u043B\u0430\u0433\u0438\u043D \u0437\u0430\u043F\u0443\u0448\u0438\u0442 \u0444\u0430\u0439\u043B, \u0443\u043A\u0430\u0436\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u0430 (\u0432 \u043F\u0430\u043F\u043A\u0435 .github/worfklows).",
      autoCleanUp: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0430\u044F \u043E\u0447\u0438\u0441\u0442\u043A\u0430",
      autoCleanUpDesc: "\u0415\u0441\u043B\u0438 \u043F\u043B\u0430\u0433\u0438\u043D \u0434\u043E\u043B\u0436\u0435\u043D \u0443\u0434\u0430\u043B\u044F\u0442\u044C \u0441 github'\u0430 \u0443\u0434\u0430\u043B\u0435\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u044B (\u0431\u043E\u043B\u044C\u0448\u0435 \u043D\u0435 \u043E\u0431\u0449\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0435 \u0438\u043B\u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u043D\u044B\u0435)",
      excludedFiles: "\u0418\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u044B",
      excludedFilesDesc: "\u0415\u0441\u043B\u0438 \u0432\u044B \u0445\u043E\u0442\u0438\u0442\u0435 \u0438\u0441\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0430\u043F\u043A\u0438 \u0438\u0437 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0439 \u043E\u0447\u0438\u0441\u0442\u043A\u0438, \u0443\u043A\u0430\u0436\u0438\u0442\u0435 \u043F\u0443\u0442\u044C \u043A \u043D\u0438\u043C."
    },
    plugin: {
      pluginSettings: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
      shareKey: "Share Key",
      shareKeyDesc: "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u043E Frontmatter(Yaml) \u0434\u043B\u044F \u043F\u043E\u043C\u0435\u0442\u043A\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 \u043A\u0430\u043A \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0445 \u0434\u043B\u044F \u043F\u0443\u0431\u043B\u0438\u043A\u0430\u0446\u0438\u0438.",
      excludedFolder: "\u0418\u0441\u043A\u043B\u044E\u0447\u0435\u043D\u043D\u044B\u0435 \u043F\u0430\u043F\u043A\u0438",
      excludedFolderDesc: "\u041D\u0438\u043A\u043E\u0433\u0434\u0430 \u043D\u0435 \u043F\u0443\u0431\u043B\u0438\u043A\u043E\u0432\u0430\u0442\u044C \u0444\u0430\u0439\u043B\u044B \u0438\u0437 \u044D\u0442\u0438\u0445 \u043F\u0430\u043F\u043E\u043A, \u0432\u043D\u0435 \u0437\u0430\u0432\u0438\u0441\u0438\u043C\u043E\u0441\u0442\u0438 \u043E\u0442 \u0444\u043B\u0430\u0433\u0430 \u043F\u0443\u0431\u043B\u0438\u043A\u0430\u0446\u0438\u0438. \u0420\u0430\u0437\u0434\u0435\u043B\u044F\u0439\u0442\u0435 \u043F\u0430\u043F\u043A\u0438 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E \u0437\u0430\u043F\u044F\u0442\u043E\u0439.",
      fileMenu: "\u0424\u0430\u0439\u043B\u043E\u0432\u043E\u0435 \u043C\u0435\u043D\u044E",
      fileMenuDesc: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043A\u043E\u043C\u0430\u043D\u0434\u044B \u0432 \u0444\u0430\u0439\u043B\u043E\u0432\u043E\u0435 \u043C\u0435\u043D\u044E",
      editorMenu: "\u041C\u0435\u043D\u044E \u0440\u0435\u0434\u0430\u043A\u0442\u043E\u0440\u0430",
      editorMenuDesc: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043A\u043E\u043C\u0430\u043D\u0434\u044B \u0432 \u043C\u0435\u043D\u044E \u043F\u043E \u043F\u0440\u0430\u0432\u043E\u0439-\u043A\u043D\u043E\u043F\u043A\u0438 \u043C\u044B\u0448\u0438",
      copyLink: {
        copylinkSetting: "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0441\u044B\u043B\u043A\u0443",
        copylinkDesc: "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0441\u044B\u043B\u043A\u0443 \u043D\u0430 \u043E\u0431\u0449\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0439 \u0444\u0430\u0439\u043B \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430",
        baselink: "\u0421\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u0431\u043B\u043E\u0433",
        baselinkDesc: "\u0421\u0441\u044B\u043B\u043A\u0438 \u0434\u043B\u044F \u0431\u0443\u0444\u0435\u0440\u0430 \u043E\u0431\u043C\u0435\u043D\u0430 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u043D\u044B \u043D\u0430 \u0431\u0430\u0437\u0435 \u044D\u0442\u043E\u0439 \u0441\u0441\u044B\u043B\u043A\u0438. \u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E : https://username.github.io/repo/",
        linkpathremover: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u0447\u0430\u0441\u0442\u044C \u0441\u0441\u044B\u043B\u043A\u0438",
        linkpathremoverDesc: "\u0423\u0434\u0430\u043B\u044F\u0442\u044C \u044D\u0442\u0443 \u0447\u0430\u0441\u0442\u044C \u0438\u0437 \u0441\u043E\u0437\u0434\u0430\u043D\u043D\u044B\u0445 \u0441\u0441\u044B\u043B\u043E\u043A. \u0415\u0441\u043B\u0438 \u043D\u0443\u0436\u043D\u043E \u0443\u0434\u0430\u043B\u044F\u0442\u044C \u043C\u043D\u043E\u0436\u0435\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0442\u0435 \u0437\u0430\u043F\u044F\u0442\u0443\u044E."
      },
      logNoticeHeader: "\u0423\u0432\u0435\u0434\u043E\u043C\u043B\u044F\u0442\u044C \u043E \u043A\u0430\u0436\u0434\u043E\u0439 \u043E\u0448\u0438\u0431\u043A\u0435",
      logNoticeDesc: "\u041D\u0430 \u043C\u043E\u0431\u0438\u043B\u044C\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0430\u0445 \u0441\u043B\u043E\u0436\u043D\u043E \u043E\u0442\u043B\u0430\u0436\u0438\u0432\u0430\u0442\u044C \u043F\u043B\u0430\u0433\u0438\u043D. \u0412\u043A\u043B\u044E\u0447\u0438\u0442\u0435 \u044D\u0442\u0443 \u043E\u043F\u0446\u0438\u044E, \u0447\u0442\u043E\u0431\u044B \u043B\u043E\u0433\u0433\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043A\u0430\u0436\u0434\u0443\u044E \u043E\u0448\u0438\u0431\u043A\u0443",
      shareExternalModifiedTitle: "Share external modified file",
      shareExternalModifiedDesc: "Send edited file if they are different from the active file. Useful when editing metadata using MetaEdit or Metadata Menu."
    },
    help: {
      help: "Help",
      usefulLinks: {
        title: "Useful links",
        documentation: "Documentation",
        repository: "Repository",
        issue: "Issue",
        discussion: "Discussion",
        links: "https://obsidian-publisher.netlify.app/"
      },
      frontmatter: {
        title: "Frontmatter keys cheatsheet",
        desc: "Moreover, there are some frontmatter YAML keys that can be usefull for your workflow. The YAML code below show the default settings, but feel free to change it to your needs in each notes!",
        share: "This key is used to share a note with the plugin.",
        mdlinks: "convert all wikilinks to markdown links",
        convert: {
          enableOrDisable: "enable or disable the conversion of links. Disabling this will remove the",
          or: "or",
          syntax: "syntax, while keeping the file name or the alias."
        },
        embed: {
          send: "send embedded note to GitHub",
          remove: "remove the embed from the note, leaving empty line."
        },
        attachment: {
          send: "send all attachments to github",
          folder: "change the default folder for the attachments"
        },
        dataview: "convert dataview queries to markdown.",
        hardBreak: "convert all linebreaks to markdown \xABhard break\xBB.",
        repo: {
          desc: "change the default repo for the note.",
          owner: "owner of the repo",
          repo: "name of the repo",
          branch: "branch of the repo"
        },
        titleKey: "change the title of the note.",
        autoclean: "disable or enable autocleaning",
        baselink: "change the base link for the copy link command"
      },
      multiRepoHelp: {
        title: "Send to multiple repository",
        desc: "If you want to send your notes to multiple repository, you can use the ",
        desc2: "key in your frontmatter. The value of this key must be a list of repository. Each repository must have the following keys ",
        exampleDesc: "The YAML code below show an example based on your settings."
      }
    }
  },
  informations: {
    startingClean: (repoInfo) => `\u041D\u0430\u0447\u0438\u043D\u0430\u044E \u043E\u0447\u0438\u0441\u0442\u043A\u0443 ${repoInfo}`,
    scanningRepo: "\u0421\u043A\u0430\u043D\u0438\u0440\u0443\u044E \u0440\u0435\u043F\u043E\u0437\u0438\u0442\u043E\u0440\u0438\u0439, \u044D\u0442\u043E \u043C\u043E\u0436\u0435\u0442 \u0437\u0430\u043D\u044F\u0442\u044C \u043A\u0430\u043A\u043E\u0435-\u0442\u043E \u0432\u0440\u0435\u043C\u044F...",
    foundNoteToSend: (noteLength) => `\u041D\u0430\u0439\u0434\u0435\u043D\u043E ${noteLength} \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u0434\u043B\u044F \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0438`,
    noNewNote: "\u041E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044E\u0442 \u043D\u043E\u0432\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u0434\u043B\u044F \u043F\u0443\u0431\u043B\u0438\u043A\u0430\u0446\u0438\u0438.",
    successfullPublish: (noticeValue) => `\u0423\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u043F\u0443\u0431\u043B\u0438\u043A\u043E\u0432\u0430\u043D\u043E ${noticeValue[0]} \u0432 ${noticeValue[1]}.`,
    waitingWorkflow: "\u041E\u0436\u0438\u0434\u0430\u044E \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0438\u044F \u043F\u0440\u043E\u0446\u0435\u0441\u0441\u0430 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0438...",
    sendMessage: (noticeValue) => `\u041E\u0442\u043F\u0440\u0430\u0432\u043B\u044F\u044E ${noticeValue[0]} \u0432 ${noticeValue[1]}${noticeValue[2]}`
  },
  error: {
    unablePublishNote: (fileInfo) => `\u041D\u0435 \u043F\u043E\u043B\u0443\u0447\u0438\u043B\u043E\u0441\u044C \u043E\u043F\u0443\u0431\u043B\u0438\u043A\u043E\u0432\u0430\u0442\u044C \u0437\u0430\u043C\u0435\u0442\u043A\u0443 ${fileInfo}\uFF0C\u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u044E`,
    errorPublish: (repoInfo) => `\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0443\u0431\u043B\u0438\u043A\u0430\u0446\u0438\u0438 \u0432 ${repoInfo}.`,
    unablePublishMultiNotes: "\u041D\u0435 \u043F\u043E\u043B\u0443\u0447\u0438\u043B\u043E\u0441\u044C \u043E\u043F\u0443\u0431\u043B\u0438\u043A\u043E\u0432\u0430\u0442\u044C \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0437\u0430\u043C\u0435\u0442\u043E\u043A, \u0447\u0442\u043E-\u0442\u043E \u043F\u043E\u0448\u043B\u043E \u043D\u0435 \u0442\u0430\u043A.",
    mergeconflic: `Pull-request is not mergeable, you need to do it manually.`,
    errorConfig: (repoInfo) => `Error configuring ${repoInfo}. Please check your settings.`
  }
};

// plugin/i18n/locales/zh-cn.ts
var zh_cn_default = {
  commands: {
    shareActiveFile: "\u4E0A\u4F20\u5F53\u524D\u6587\u4EF6",
    publisherDeleteClean: "\u4E91\u7AEF\u79FB\u9664\u672C\u5730\u672A\u5206\u4EAB\u548C\u5DF2\u5220\u9664\u7684\u6587\u4EF6",
    uploadAllNotes: "\u4E0A\u4F20\u6240\u6709\u5206\u4EAB\u7684\u6587\u4EF6",
    uploadNewNotes: "\u4E0A\u4F20\u65B0\u5206\u4EAB\u7684\u6587\u4EF6",
    uploadAllNewEditedNote: "\u4E0A\u4F20\u65B0\u5EFA\u7ACB\u6587\u4EF6\u7684\u548C\u66F4\u65B0\u5DF2\u7F16\u8F91\u7684\u5206\u4EAB\u6587\u4EF6",
    uploadAllEditedNote: "\u66F4\u65B0\u6240\u6709\u5DF2\u7F16\u8F91\u7684\u6587\u4EF6",
    shareViewFiles: (viewFile) => `\u7528Mkdocs Publisher\u5171\u4EAB"${viewFile}"\u3002`
  },
  deletion: {
    errorDeleteDefaultFolder: "You need a default folder name in the settings to use this command.",
    errorDeleteRootFolder: "You need to configure a root folder in the settings to use this command.",
    successDeleting: (nb) => `Successfully deleted ${nb} files.`,
    failedDeleting: (nb) => `Failed to delete ${nb} files.`,
    noFileDeleted: "No files have been deleted."
  },
  settings: {
    github: {
      githubConfiguration: "Github\u8BBE\u7F6E",
      repoName: "\u4ED3\u5E93\u540D",
      repoNameDesc: "\u4F60\u535A\u5BA2\u6240\u5728\u7684github\u4ED3\u5E93\u540D",
      mkdocsTemplate: "mkdocs\u6A21\u677F",
      githubUsername: "Github\u7528\u6237\u540D",
      githubUsernameDesc: "\u4F60github\u7684\u7528\u6237\u540D",
      ghTokenDesc: "github\u4ED3\u5E93\u7684\u64CD\u4F5C\u9700\u8981github token\u7ED9\u4E88\u6743\u9650\uFF0C\u4F60\u53EF\u4EE5\u5728",
      here: "\u8FD9\u91CC\u751F\u6210",
      githubToken: "Github Token",
      githubBranchHeading: "Main branch",
      githubBranchDesc: 'If you use a different main branch than "main", you can specify it here.',
      automaticallyMergePR: "Automatically merge PR"
    },
    uploadConfig: {
      uploadConfig: "\u4E0A\u4F20\u8BBE\u7F6E",
      pathSetting: "\u8DEF\u5F84\u8BBE\u7F6E",
      folderBehavior: "\u6587\u4EF6\u5939\u64CD\u4F5C",
      folderBehaviorDesc: "\u9009\u62E9\u4F9D\u636E\u56FA\u5B9A\u6587\u4EF6\u5939\uFF0Cfrontmatter key\u8FD8\u662Fob\u7684\u76F8\u5BF9\u8DEF\u5F84\u4E0A\u4F20\u6587\u4EF6",
      fixedFolder: "\u56FA\u5B9A\u6587\u4EF6\u5939",
      yaml: "YAML frontmatter",
      obsidianPath: "Obsidian\u76F8\u5BF9\u8DEF\u5F84",
      defaultFolder: "\u9ED8\u8BA4github\u63A5\u6536\u7684\u6587\u4EF6\u5939",
      defaultFolderDesc: "\u9ED8\u8BA4github\u9ED8\u8BA4\u63A5\u6536\u7684\u6587\u4EF6\u5939",
      defaultFolderPlaceholder: "docs",
      pathRemoving: "\u79FB\u9664\u8DEF\u5F84",
      pathRemovingDesc: "\u5141\u8BB8\u901A\u8FC7\u5220\u9664\u4E4B\u524D\u7684\u8DEF\u5F84\u4EC5\u53D1\u5E03\u5B50\u6587\u4EF6\u5939:",
      pathRemovingPlaceholder: "GardenSketch",
      frontmatterKey: "Frontmatter key",
      frontmatterKeyDesc: "\u8BBE\u7F6E\u4E91\u7AEF\u7528\u4E8E\u5EFA\u7ACB\u6587\u4EF6\u5939\u540D\u7684\u952E\uFF0C\u9ED8\u8BA4\u4E3Acategory",
      frontmatterKeyPlaceholder: "category",
      rootFolder: "\u6839\u6587\u4EF6\u5939",
      rootFolderDesc: "\u5C06\u6B64\u8DEF\u5F84\u8FFD\u52A0\u5230\u6587\u4EF6\u5939\u524D",
      useFrontmatterTitle: "Set the title from the frontmatter",
      useFrontmatterTitleDesc: 'Use a frontmatter value to generate the filename. By default, "title" is used.'
    },
    textConversion: {
      textConversion: "\u6587\u672C\u8F6C\u6362",
      textConversionDesc: "Theses option won't change the content of the file in your Obsidian Vault, but will change the content of the file in Github.",
      textHeader: "\u6587\u672C",
      hardBreakTitle: "\u9A6C\u514B\u987F\u7684\u786C\u65AD\u884C",
      hardBreakDesc: "\u5728\u6BCF\u4E00\u884C\u4E4B\u540E\u6DFB\u52A0\u4E00\u4E2A\u6807\u8BB0\u6027\u7684\u786C\u65AD\u884C\uFF08\u53CC\u500D\u7A7A\u767D\uFF09\u3002",
      links: {
        header: "\u94FE\u63A5",
        internals: "\u5185\u90E8\u94FE\u63A5",
        internalsDesc: "\u8F6C\u6362\u53D1\u5E03\u6587\u4EF6\u4E2D\u7684\u5185\u90E8\u94FE\u63A5",
        desc: 'You can prevent links to be converted and keep the alt text (or filename) by using the frontmatter key "links" with the value "false".',
        wikilinks: "[[Wikilinks]]",
        wikilinksDesc: "\u8F6C\u6362wiki link\u4E3Amd link\uFF0C\u4E0D\u6539\u53D8\u6587\u4EF6\u5185\u5BB9",
        folderNote: "Folder note",
        folderNoteDesc: '\u91CD\u547D\u540D\u6587\u4EF6\u4E3A\u5176\u7236\u6587\u4EF6\u5939\u540D(\u6216category\u540D) "index.md"'
      },
      censor: {
        TextHeader: "Text replacer",
        TextDesc: "Replace text (or regex) in the file with the given value.",
        TextFlags: "Flags (based on JS regex and can be combined) :",
        flags: {
          insensitive: "i : Insensitive.",
          global: "g : Global",
          multiline: "m : Multiline",
          dotAll: "s : DotAll",
          unicode: "u : Unicode",
          sticky: "y : Sticky",
          error: (flag) => `The flag "${flag}" is not valid.`
        },
        TextEmpty: "Replacement can be empty to remove the whole string.",
        ToolTipAdd: "Add a new text replacer",
        ToolTipRemove: "Delete this text replacer",
        PlaceHolder: "Regex or text to replace",
        ValuePlaceHolder: "Replacement value",
        Before: "Run it before the other plugin conversion (link, dataview, etc.)",
        After: "Run it after the other plugin conversion (link, dataview, etc.)"
      },
      dataview: {
        header: "Dataview",
        desc: "Convert dataview to markdown."
      },
      tags: {
        inlineTagsHeader: "Inline tags",
        inlineTagsDesc: 'Add your inline tags in your frontmatter tags field and converting nested tags with replacing "/" with "_"',
        header: "Convert frontmatter/dataview field to tags",
        desc: "This will convert any frontmatter or dataview inline field into frontmatter tags. Separate fields with a comma.",
        ExcludeHeader: "Exclude value from conversion",
        ExcludeDesc: "This will exclude value from being converted. Separate fields with a comma."
      }
    },
    embed: {
      embed: "\u5D4C\u5165",
      transferImage: "\u8F6C\u6362\u56FE\u7247",
      transferImageDesc: "\u53D1\u9001\u6587\u4EF6\u4E2D\u63D2\u5165\u7684\u56FE\u7247\u81F3github",
      transferEmbeddedNotes: "\u8F6C\u6362\u5D4C\u5165\u7684\u7B14\u8BB0",
      transferEmbeddedNotesDesc: "\u53D1\u5E03\u6587\u4EF6\u4E2D\u5D4C\u5165\u7684\u6587\u4EF6\u81F3github.\u8BE5\u5D4C\u5165\u6587\u4EF6\u9700\u8981\u5141\u8BB8\u88AB\u53D1\u5E03",
      defaultImageFolder: "\u9ED8\u8BA4\u56FE\u7247\u6587\u4EF6\u5939",
      defaultImageFolderDesc: "\u4F7F\u7528\u4E0E\u9ED8\u8BA4\u6587\u6863\u5939\u4E0D\u540C\u7684\u6587\u6863\u5939",
      transferMetaFile: "Send files using a metadata field",
      transferMetaFileDesc: "Set the names of the metadata field you want to use to send files. Separate fields with a comma. Dataview inline field are supported."
    },
    githubWorkflow: {
      githubActionName: "Github action\u540D",
      githubActionNameDesc: "\u5982\u679C\u8981\u5728\u63D2\u4EF6\u63A8\u9001\u6587\u6863\u65F6\u6FC0\u6D3B github action\uFF0C\u8BF7\u8BBE\u7F6E\u5BF9\u5E94\u7684action\u540D\u79F0\uFF08\u5728 .github/worfklows \u6587\u6863\u5939\u4E2D\uFF09\u3002",
      autoCleanUp: "\u81EA\u52A8\u6E05\u7406",
      autoCleanUpDesc: "\u5982\u679C\u63D2\u4EF6\u5FC5\u987B\u4ECEgithub\u4E2D\u5220\u9664\u672C\u5730\u5DF2\u5220\u9664\u7684\u6587\u6863\uFF08\u505C\u6B62\u5171\u4EAB\u6216\u5220\u9664\uFF09",
      excludedFiles: "\u6392\u9664\u6587\u4EF6",
      excludedFilesDesc: "\u5982\u679C\u8981\u4ECE\u81EA\u52A8\u6E05\u7406\u4E2D\u6392\u9664\u67D0\u4E9B\u6587\u6863\u5939\uFF0C\u8BF7\u8BBE\u7F6E\u5176\u8DEF\u5F84\u3002"
    },
    plugin: {
      pluginSettings: "\u63D2\u4EF6\u8BBE\u7F6E",
      shareKey: "\u5206\u4EAB\u952E",
      shareKeyDesc: "\u5728\u7F51\u7AD9\u4E0A\u53D1\u5E03\u6587\u6863\u7684frontmatter\u7684\u952E",
      excludedFolder: "\u6392\u9664\u6587\u4EF6\u5939",
      excludedFolderDesc: "\u6392\u9664\u8BE5\u6587\u6863\u5939\u4E2D\u6240\u6709\u6587\u6863\uFF0C\u65E0\u8BBA\u662F\u5426\u6709\u5206\u4EAB\u952E\u7684frontmatter\u3002\u591A\u4E2A\u6587\u4EF6\u5939\u7528\u9017\u53F7\u5206\u9694\u3002",
      fileMenu: "\u6587\u4EF6\u83DC\u5355",
      fileMenuDesc: "\u5728\u6587\u4EF6\u6811\u6DFB\u52A0\u53F3\u952E\u5206\u4EAB\u547D\u4EE4",
      editorMenu: "\u7F16\u8F91\u5668\u83DC\u5355",
      editorMenuDesc: "\u5728\u53F3\u952E\u6DFB\u52A0\u5206\u4EAB\u547D\u4EE4",
      copyLink: {
        copylinkSetting: "\u590D\u5236\u94FE\u63A5\u8BBE\u7F6E",
        copylinkDesc: "\u5728\u4F60\u7684\u526A\u8D34\u677F\u4E2D\u53D1\u9001\u4E00\u4E2A\u94FE\u63A5\u5230\u4F60\u7684\u7B14\u8BB0\u4E0A",
        baselink: "\u535A\u5BA2\u94FE\u63A5",
        baselinkDesc: "\u4EE5\u6B64\u4E3A\u57FA\u7840\u521B\u5EFA\u526A\u8D34\u677F\u94FE\u63A5\u3002\u9ED8\u8BA4\u60C5\u51B5\u4E0B : https://username.github.io/repo/",
        linkpathremover: "\u5220\u9664\u94FE\u63A5\u90E8\u5206",
        linkpathremoverDesc: "\u4ECE\u521B\u5EFA\u7684\u94FE\u63A5\u4E2D\u5220\u9664\u8FD9\u90E8\u5206\u3002\u5982\u679C\u5FC5\u987B\u5220\u9664\u591A\u4E2A\u503C\uFF0C\u8BF7\u7528\u9017\u53F7\u5206\u5F00\u3002"
      },
      logNoticeHeader: "\u6CE8\u610F\u6BCF\u4E00\u4E2A\u9519\u8BEF",
      logNoticeDesc: "\u5728\u79FB\u52A8\u8BBE\u5907\u4E0A\uFF0C\u8C03\u8BD5\u6A21\u5757\u53EF\u80FD\u5F88\u56F0\u96BE\u3002\u542F\u7528\u8BE5\u9009\u9879\u53EF\u4EE5\u901A\u8FC7Obsidian\u901A\u77E5\u6765\u901A\u77E5\u6240\u6709\u9519\u8BEF\u3002",
      shareExternalModifiedTitle: "Share external modified file",
      shareExternalModifiedDesc: "Send edited file if they are different from the active file. Useful when editing metadata using MetaEdit or Metadata Menu."
    },
    help: {
      help: "Help",
      usefulLinks: {
        title: "Useful links",
        documentation: "Documentation",
        repository: "Repository",
        issue: "Issue",
        discussion: "Discussion",
        links: "https://obsidian-publisher.netlify.app/"
      },
      frontmatter: {
        title: "Frontmatter keys cheatsheet",
        desc: "Moreover, there are some frontmatter YAML keys that can be usefull for your workflow. The YAML code below show the default settings, but feel free to change it to your needs in each notes!",
        share: "This key is used to share a note with the plugin.",
        mdlinks: "convert all wikilinks to markdown links",
        convert: {
          enableOrDisable: "enable or disable the conversion of links. Disabling this will remove the",
          or: "or",
          syntax: "syntax, while keeping the file name or the alias."
        },
        embed: {
          send: "send embedded note to GitHub",
          remove: "remove the embed from the note, leaving empty line."
        },
        attachment: {
          send: "send all attachments to github",
          folder: "change the default folder for the attachments"
        },
        dataview: "convert dataview queries to markdown.",
        hardBreak: "convert all linebreaks to markdown \xABhard break\xBB.",
        repo: {
          desc: "change the default repo for the note.",
          owner: "owner of the repo",
          repo: "name of the repo",
          branch: "branch of the repo"
        },
        titleKey: "change the title of the note.",
        autoclean: "disable or enable autocleaning",
        baselink: "change the base link for the copy link command"
      },
      multiRepoHelp: {
        title: "Send to multiple repository",
        desc: "If you want to send your notes to multiple repository, you can use the ",
        desc2: "key in your frontmatter. The value of this key must be a list of repository. Each repository must have the following keys ",
        exampleDesc: "The YAML code below show an example based on your settings."
      }
    }
  },
  information: {
    startingClean: (repoInfo) => `\u5F00\u59CB\u6E05\u7406 ${repoInfo}`,
    scanningRepo: "\u626B\u63CF\u4ED3\u5E93\u4E2D\uFF0C\u7A0D\u7B49...",
    foundNoteToSend: (noteLength) => `\u53D1\u73B0 ${noteLength} \u7BC7\u7B14\u8BB0\u9700\u8981\u4E0A\u4F20`,
    noNewNote: "\u6CA1\u6709\u65B0\u7B14\u8BB0\u9700\u8981\u4E0A\u4F20.",
    successfullPublish: (noticeValue) => `\u6210\u529F\u5730\u5C06${noticeValue[0]}\u53D1\u5E03\u5230${noticeValue[1]}\u3002`,
    waitingWorkflow: "\u73B0\u5728\uFF0C\u7B49\u5F85\u5DE5\u4F5C\u6D41\u7A0B\u7684\u5B8C\u6210...",
    sendMessage: (noticeValue) => `\u5C06${noticeValue[0]}\u53D1\u9001\u5230${noticeValue[1]}${noticeValue[2]}\u3002`
  },
  error: {
    unablePublishNote: (fileInfo) => {
      return `\u4E0D\u80FD\u4E0A\u4F20\u6587\u4EF6${fileInfo}\uFF0C\u5DF2\u8DF3\u8FC7`;
    },
    errorPublish: (repoInfo) => `\u4E0A\u4F20\u81F3${repoInfo}\u9519\u8BEF\uFF01`,
    unablePublishMultiNotes: "\u4E0D\u80FD\u4E0A\u4F20\u591A\u4E2A\u6587\u4EF6\uFF0C\u51FA\u4E86\u70B9\u95EE\u9898",
    mergeconflic: `Pull-request is not mergeable, you need to do it manually.`,
    errorConfig: (repoInfo) => `Error configuring ${repoInfo}. Please check your settings.`
  }
};

// plugin/i18n/index.ts
var localeMap = {
  en: en_default,
  fr: fr_default,
  ru: ru_default,
  "zh-cn": zh_cn_default
};
var locale = localeMap[import_obsidian.moment.locale()];
function error(str) {
  return locale && locale.error[str] || en_default.error[str];
}
function commands(key) {
  return locale && locale.commands[key] || en_default.commands[key];
}
function deletion(key) {
  return locale && locale.deletion[key] || en_default.deletion[key];
}
function settings(type, msg) {
  return locale && locale.settings[type][msg] || en_default.settings[type][msg];
}
function nestedProp(obj, path) {
  return path.split(".").reduce((o, k) => o ? o[k] : void 0, obj);
}
function subSettings(multipleKey) {
  return locale && nestedProp(locale.settings, multipleKey) || nestedProp(en_default.settings, multipleKey);
}
function informations(key) {
  return locale && locale.informations[key] || en_default.informations[key];
}

// plugin/settings/interface.ts
var DEFAULT_SETTINGS = {
  githubRepo: "",
  githubName: "",
  GhToken: "",
  githubBranch: "main",
  shareKey: "share",
  ExcludedFolder: "",
  fileMenu: false,
  editorMenu: false,
  downloadedFolder: "fixed" /* fixed */,
  folderDefaultName: "",
  yamlFolderKey: "",
  rootFolder: "",
  workflowName: "",
  embedImage: true,
  defaultImageFolder: "",
  autoCleanUp: false,
  autoCleanUpExcluded: [],
  folderNote: false,
  convertWikiLinks: false,
  convertForGithub: false,
  subFolder: "",
  embedNotes: false,
  copyLink: false,
  mainLink: "",
  linkRemover: "",
  hardBreak: false,
  logNotice: false,
  convertDataview: true,
  useFrontmatterTitle: false,
  censorText: [],
  inlineTags: false,
  dataviewFields: [],
  excludeDataviewValue: [],
  metadataFileFields: [],
  frontmatterTitleKey: "title",
  shareExternalModified: false,
  automaticallyMergePR: true
};
var PUBLISHER_TABS = {
  "github-configuration": {
    name: settings("github", "githubConfiguration"),
    icon: "cloud"
  },
  "upload-configuration": {
    name: "Upload Configuration",
    icon: "upload"
  },
  "text-conversion": {
    name: settings("textConversion", "textConversion"),
    icon: "file-text"
  },
  "embed-configuration": {
    name: settings("embed", "embed"),
    icon: "link"
  },
  "plugin-settings": {
    name: settings("plugin", "pluginSettings"),
    icon: "gear"
  },
  "help": {
    name: subSettings("help.help"),
    icon: "info"
  }
};

// plugin/settings/style.ts
function showSettings(containerEl) {
  containerEl.descEl.show();
  containerEl.nameEl.show();
  containerEl.controlEl.show();
}
function hideSettings(containerEl) {
  containerEl.descEl.hide();
  containerEl.nameEl.hide();
  containerEl.controlEl.hide();
}
function autoCleanCondition(value, autoCleanSetting, plugin) {
  return __async(this, null, function* () {
    const settings2 = plugin.settings;
    if (value.length === 0 && settings2.downloadedFolder) {
      settings2.autoCleanUp = false;
      yield plugin.saveSettings();
      autoCleanSetting.setDisabled(true);
      autoCleanSetting.components[0].toggleEl.classList.remove("is-enabled");
    } else if (value.length === 0 && settings2.downloadedFolder !== "yaml" /* yaml */) {
      settings2.autoCleanUp = false;
      autoCleanSetting.setDisabled(true);
      autoCleanSetting.components[0].toggleEl.classList.remove("is-enabled");
    } else {
      autoCleanSetting.setDisabled(false);
      if (settings2.autoCleanUp) {
        autoCleanSetting.components[0].toggleEl.classList.add("is-enabled");
      }
    }
  });
}
function folderHideShowSettings(frontmatterKeySettings, rootFolderSettings, autoCleanSetting, value, plugin, subFolderSettings) {
  return __async(this, null, function* () {
    const settings2 = plugin.settings;
    if (value === "yaml" /* yaml */) {
      showSettings(frontmatterKeySettings);
      showSettings(rootFolderSettings);
      autoCleanCondition(settings2.rootFolder, autoCleanSetting, plugin).then();
      hideSettings(subFolderSettings);
    } else {
      if (settings2.folderDefaultName.length > 0) {
        autoCleanSetting.setDisabled(false);
        if (settings2.autoCleanUp) {
          autoCleanSetting.components[0].toggleEl.classList.add("is-enabled");
        }
      }
      if (settings2.downloadedFolder === "obsidian" /* obsidian */) {
        showSettings(subFolderSettings);
      } else {
        hideSettings(subFolderSettings);
      }
      hideSettings(frontmatterKeySettings);
      hideSettings(rootFolderSettings);
    }
  });
}
function autoCleanUpSettingsOnCondition(condition, autoCleanSetting, plugin) {
  const settings2 = plugin.settings;
  if (condition) {
    autoCleanSetting.setDisabled(true);
    autoCleanSetting.components[0].toggleEl.classList.remove("is-enabled");
    settings2.autoCleanUp = false;
    plugin.saveSettings().then();
  } else {
    autoCleanSetting.setDisabled(false);
    if (settings2.autoCleanUp) {
      autoCleanSetting.components[0].toggleEl.classList.add("is-enabled");
    }
  }
}
function shortcutsHideShow(condition, toDisplay) {
  condition ? showSettings(toDisplay) : hideSettings(toDisplay);
}

// plugin/settings/help.ts
function help(settings2) {
  const explanation = document.createDocumentFragment();
  explanation.createEl("ul", null, (span) => {
    span.createEl("li", null, (span2) => {
      span2.createEl("code", { text: `${settings2.shareKey}:`, cls: "code-title" });
      span2.createEl("span", {
        text: ` ${subSettings("help.frontmatter.share")}`
      });
    });
    span.createEl("li", null, (span2) => {
      span2.createEl("code", { text: "links:", cls: "code-title" });
    });
    span.createEl("ul", null, (l) => {
      l.createEl("li", null, (p) => {
        p.createEl("code", { text: "mdlinks" });
        p.createEl("span", { text: `: ${subSettings("help.frontmatter.mdlinks")}` });
      });
      l.createEl("li", null, (p) => {
        p.createEl("code", { text: "convert" });
        p.createEl("span", null, (span2) => {
          span2.createEl("span", { text: `: ${subSettings("help.frontmatter.convert.enableOrDisable")} ` });
          span2.createEl("code", { text: " [[link]] " });
          span2.createEl("span", { text: subSettings("help.frontmatter.convert.or") });
          span2.createEl("code", { text: " [](link) " });
          span2.createEl("span", { text: subSettings("help.frontmatter.convert.syntax") });
        });
      });
    });
    span.createEl("li", { text: "embed:", cls: "code code-title" });
    span.createEl("ul", null, (l) => {
      l.createEl("li", null, (p) => {
        p.createEl("code", { text: "send" });
        p.createEl("span", { text: `: ${subSettings("help.frontmatter.embed.send")}` });
      });
      l.createEl("li", null, (p) => {
        p.createEl("code", { text: "remove" });
        p.createEl("span", { text: `: ${subSettings("help.frontmatter.embed.remove")}` });
      });
    });
    span.createEl("li", { text: "attachment:", cls: "code code-title" });
    span.createEl("ul", null, (l) => {
      l.createEl("li", null, (span2) => {
        span2.createEl("code", { text: "send" });
        span2.createEl("span", { text: `: ${subSettings("help.frontmatter.attachment.send")}` });
      });
      l.createEl("li", null, (p) => {
        p.createEl("code", { text: "folder" });
        p.createEl("span", { text: `: ${subSettings("help.frontmatter.attachment.folder")}` });
      });
    });
    span.createEl("li", null, (span2) => {
      span2.createEl("code", { text: "dataview", cls: "code-title" });
      span2.createEl("span", { text: `: ${subSettings("help.frontmatter.dataview")}` });
    });
    span.createEl("li", null, (span2) => {
      span2.createEl("code", { text: "hardbreak", cls: "code-title" });
      span2.createEl("span", { text: `: ${subSettings("help.frontmatter.hardBreak")}` });
    });
    span.createEl("li", null, (span2) => {
      span2.createEl("code", { text: "repo", cls: "code-title" });
      span2.createEl("span", { text: `: ${subSettings("help.frontmatter.repo.desc")}` });
      span2.createEl("ul", null, (ul) => {
        ul.createEl("li", null, (li) => {
          li.createEl("code", { text: "owner" });
          li.createEl("span", { text: `: ${subSettings("help.frontmatter.repo.owner")}` });
        });
        ul.createEl("li", null, (li) => {
          li.createEl("code", { text: "repo" });
          li.createEl("span", { text: `: ${subSettings("help.frontmatter.repo.repo")}` });
        });
        ul.createEl("li", null, (li) => {
          li.createEl("code", { text: "branch" });
          li.createEl("span", { text: `: ${subSettings("help.frontmatter.repo.branch")}` });
        });
      });
    });
    span.createEl("li", null, (span2) => {
      span2.createEl("code", { text: `${settings2.frontmatterTitleKey}`, cls: "code-title" });
      span2.createEl("span", { text: `: ${subSettings("help.frontmatter.titleKey")}` });
    });
    span.createEl("li", null, (span2) => {
      span2.createEl("code", { text: "autoclean", cls: "code-title" });
      span2.createEl("span", { text: `: ${subSettings("help.frontmatter.autoclean")}` });
    });
    span.createEl("li", null, (span2) => {
      span2.createEl("code", { text: "baseLink", cls: "code-title" });
      span2.createEl("span", { text: `: ${subSettings("help.frontmatter.baselink")}` });
    });
  });
  return explanation;
}
function usefullLinks() {
  const usefullLinks2 = document.createDocumentFragment();
  usefullLinks2.createEl("ul", null, (el) => {
    el.createEl("li", null, (el2) => {
      el2.createEl("a", { text: subSettings("help.usefulLinks.documentation"), href: subSettings("help.usefulLinks.links") });
    });
    el.createEl("li", null, (el2) => {
      el2.createEl("a", { text: subSettings("help.usefulLinks.repository"), href: "https://github.com/ObsidianPublisher/obsidian-github-publisher" });
    });
    el.createEl("li", null, (el2) => {
      el2.createEl("a", { text: subSettings("help.usefulLinks.issue"), href: "https://github.com/ObsidianPublisher/obsidian-github-publisher/issues" });
    });
    el.createEl("li", null, (el2) => {
      el2.createEl("a", { text: subSettings("help.usefulLinks.discussion"), href: "https://github.com/ObsidianPublisher/obsidian-github-publisher/discussions" });
    });
  });
  return usefullLinks2;
}
function multipleRepoExplained(settings2) {
  const multipleRepoExplained2 = document.createDocumentFragment();
  multipleRepoExplained2.createEl("p", null, (el) => {
    el.createEl("span", { text: subSettings("help.multiRepoHelp.desc") });
    el.createEl("code", { text: "multipleRepo" });
    el.createEl("span", { text: ` ${subSettings("help.multiRepoHelp.desc2")}:` });
    el.createEl("ul", null, (el2) => {
      el2.createEl("li", { text: "owner" }).addClass("code");
      el2.createEl("li", { text: "repo" }).addClass("code");
      el2.createEl("li", { text: "branch" }).addClass("code");
    });
    el.createEl("span", { text: subSettings("help.multiRepoHelp.exampleDesc") });
  });
  multipleRepoExplained2.createEl("pre", { cls: "language-yaml" }).createEl("code", { text: `multipleRepo:
  - owner: ${settings2.githubName}
    repo: ${settings2.githubRepo}
    branch: ${settings2.githubBranch}
  - owner: ${settings2.githubName}
    repo: my_second_brain
    branch: master`, cls: "language-yaml" });
  return multipleRepoExplained2;
}
function supportMe() {
  const supportMe2 = document.createDocumentFragment();
  supportMe2.createEl("p", null, (el) => {
    el.createEl("a", null, (el2) => {
      el2.createEl("img", null, (img) => {
        img.setAttr("src", "https://storage.ko-fi.com/cdn/kofi2.png?v=3");
        img.setAttr("alt", "Buy Me A Coffee");
        img.setAttr("style", "height: 60px !important;width: 217px !important;");
      });
      el2.setAttr("href", "https://ko-fi.com/lisandra_dev");
    });
    el.setAttr("style", "text-align: center;");
  });
  return supportMe2;
}

// plugin/settings.ts
function openDetails(groupName, detailsState) {
  for (let i = 0; i < document.getElementsByTagName("details").length; i++) {
    const details = document.getElementsByTagName("details")[i];
    if (details.innerText === groupName && detailsState) {
      details.open = true;
    }
  }
}
var GithubPublisherSettings = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const tabBar = containerEl.createEl("nav", { cls: "settings-tab-bar obs-git-publisher" });
    for (const [tabID, tabInfo] of Object.entries(PUBLISHER_TABS)) {
      const tabEl = tabBar.createEl("div", { cls: "settings-tab obs-git-publisher" });
      const tabIcon = tabEl.createEl("div", { cls: "settings-tab-icon obs-git-publisher" });
      (0, import_obsidian2.setIcon)(tabIcon, tabInfo.icon);
      tabEl.createEl("div", { cls: "settings-tab-name obs-git-publisher", text: tabInfo.name });
      if (tabID === "github-configuration")
        tabEl.addClass("settings-tab-active");
      tabEl.addEventListener("click", () => {
        for (const tabEl2 of tabBar.children)
          tabEl2.removeClass("settings-tab-active");
        tabEl.addClass("settings-tab-active");
        this.renderSettingsPage(tabID);
      });
    }
    this.settingsPage = containerEl.createEl("div", { cls: "settings-tab-page obs-git-publisher" });
    this.renderSettingsPage("github-configuration");
  }
  renderSettingsPage(tabId) {
    this.settingsPage.empty();
    switch (tabId) {
      case "github-configuration":
        this.renderGithubConfiguration();
        break;
      case "upload-configuration":
        this.renderUploadConfiguration();
        break;
      case "text-conversion":
        this.renderTextConversion();
        break;
      case "embed-configuration":
        this.renderEmbedConfiguration();
        break;
      case "plugin-settings":
        this.renderPluginSettings();
        break;
      case "help":
        this.renderHelp();
        break;
    }
  }
  renderGithubConfiguration() {
    new import_obsidian2.Setting(this.settingsPage).setName(settings("github", "repoName")).setDesc(settings("github", "repoNameDesc")).addText((text) => text.setPlaceholder("mkdocs-template").setValue(this.plugin.settings.githubRepo).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.githubRepo = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.settingsPage).setName(settings("github", "githubUsername")).setDesc(settings("github", "githubUsernameDesc")).addText((text) => text.setPlaceholder(settings("github", "githubUsername")).setValue(this.plugin.settings.githubName).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.githubName = value.trim();
      yield this.plugin.saveSettings();
    })));
    const desc_ghToken = document.createDocumentFragment();
    desc_ghToken.createEl("span", null, (span) => {
      span.innerText = settings("github", "ghTokenDesc");
      span.createEl("a", null, (link) => {
        link.innerText = settings("github", "here");
        link.href = "https://github.com/settings/tokens/new?scopes=repo,workflow";
      });
    });
    new import_obsidian2.Setting(this.settingsPage).setName(settings("github", "githubToken")).setDesc(desc_ghToken).addText((text) => text.setPlaceholder("ghb-15457498545647987987112184").setValue(this.plugin.settings.GhToken).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.GhToken = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.settingsPage).setName(settings("github", "githubBranchHeading")).setDesc(settings("github", "githubBranchDesc")).addText((text) => text.setPlaceholder("main").setValue(this.plugin.settings.githubBranch).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.githubBranch = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.settingsPage).setName(settings("github", "automaticallyMergePR")).addToggle((toggle) => toggle.setValue(this.plugin.settings.automaticallyMergePR).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.automaticallyMergePR = value;
      yield this.plugin.saveSettings();
    })));
  }
  renderUploadConfiguration() {
    this.settingsPage.createEl("h3", {
      text: settings("uploadConfig", "pathSetting")
    });
    new import_obsidian2.Setting(this.settingsPage).setName(settings("uploadConfig", "folderBehavior")).setDesc(settings("uploadConfig", "folderBehaviorDesc")).addDropdown((dropDown) => {
      dropDown.addOptions({
        fixed: settings("uploadConfig", "fixedFolder"),
        yaml: settings("uploadConfig", "yaml"),
        obsidian: settings("uploadConfig", "obsidianPath")
      }).setValue(this.plugin.settings.downloadedFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.downloadedFolder = value;
        yield folderHideShowSettings(frontmatterKeySettings, rootFolderSettings, autoCleanSetting, value, this.plugin, subFolderSettings);
        this.settingsPage.empty();
        this.renderUploadConfiguration();
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(this.settingsPage).setName(settings("uploadConfig", "defaultFolder")).setDesc(settings("uploadConfig", "defaultFolderDesc")).addText((text) => {
      text.setPlaceholder("docs").setValue(this.plugin.settings.folderDefaultName).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.folderDefaultName = value.replace(/\/$/, "");
        yield autoCleanCondition(value, autoCleanSetting, this.plugin);
        yield this.plugin.saveSettings();
      }));
    });
    const subFolderSettings = new import_obsidian2.Setting(this.settingsPage).setName(settings("uploadConfig", "pathRemoving")).setClass("obs-git-publisher").setDesc(settings("uploadConfig", "pathRemovingDesc")).addText((text) => {
      text.setPlaceholder(settings("uploadConfig", "pathRemovingPlaceholder")).setValue(this.plugin.settings.subFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.subFolder = value.replace(/\/$/, "").trim();
        yield this.plugin.saveSettings();
      }));
    });
    const frontmatterKeySettings = new import_obsidian2.Setting(this.settingsPage).setName(settings("uploadConfig", "frontmatterKey")).setClass("obs-git-publisher").setDesc(settings("uploadConfig", "frontmatterKeyDesc")).addText((text) => {
      text.setPlaceholder("category").setValue(this.plugin.settings.yamlFolderKey).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.yamlFolderKey = value.trim();
        yield this.plugin.saveSettings();
      }));
    });
    const rootFolderSettings = new import_obsidian2.Setting(this.settingsPage).setName(settings("uploadConfig", "rootFolder")).setClass("obs-git-publisher").setDesc(settings("uploadConfig", "rootFolderDesc")).addText((text) => {
      text.setPlaceholder("docs").setValue(this.plugin.settings.rootFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.rootFolder = value.replace(/\/$/, "");
        yield autoCleanCondition(value, autoCleanSetting, this.plugin);
        yield this.plugin.saveSettings();
      }));
    });
    const frontmatterTitleSet = new import_obsidian2.Setting(this.settingsPage).setName(settings("uploadConfig", "useFrontmatterTitle")).setDesc(settings("uploadConfig", "useFrontmatterTitleDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useFrontmatterTitle).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.useFrontmatterTitle = value;
        yield this.plugin.saveSettings();
        this.settingsPage.empty();
        this.renderUploadConfiguration();
      }));
    });
    if (this.plugin.settings.useFrontmatterTitle) {
      frontmatterTitleSet.addText((text) => {
        text.setPlaceholder("title").setValue(this.plugin.settings.frontmatterTitleKey).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.frontmatterTitleKey = value.trim();
          yield this.plugin.saveSettings();
        }));
      });
    }
    if (this.plugin.settings.downloadedFolder === "yaml" /* yaml */) {
      showSettings(frontmatterKeySettings);
      showSettings(rootFolderSettings);
      hideSettings(subFolderSettings);
    } else {
      hideSettings(frontmatterKeySettings);
      hideSettings(rootFolderSettings);
      if (this.plugin.settings.downloadedFolder === "obsidian" /* obsidian */) {
        showSettings(subFolderSettings);
      } else {
        hideSettings(subFolderSettings);
      }
    }
    this.settingsPage.createEl("h3", { text: "Github Workflow" });
    new import_obsidian2.Setting(this.settingsPage).setName(settings("githubWorkflow", "githubActionName")).setDesc(settings("githubWorkflow", "githubActionNameDesc")).addText((text) => {
      text.setPlaceholder("ci").setValue(this.plugin.settings.workflowName).onChange((value) => __async(this, null, function* () {
        value = value.length > 0 ? value.trim().replace(".yml", "") + ".yml" : value;
        this.plugin.settings.workflowName = value;
        yield this.plugin.saveSettings();
      }));
    });
    const condition = this.plugin.settings.downloadedFolder === "yaml" /* yaml */ && this.plugin.settings.rootFolder.length === 0 || this.plugin.settings.folderDefaultName.length === 0;
    const autoCleanSetting = new import_obsidian2.Setting(this.settingsPage).setName(settings("githubWorkflow", "autoCleanUp")).setDesc(settings("githubWorkflow", "autoCleanUpDesc")).setDisabled(condition).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoCleanUp).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.autoCleanUp = value;
        shortcutsHideShow(value, autoCleanExcludedSettings);
        yield this.plugin.saveSettings();
      }));
    });
    const autoCleanExcludedSettings = new import_obsidian2.Setting(this.settingsPage).setName(settings("githubWorkflow", "excludedFiles")).setDesc(settings("githubWorkflow", "excludedFilesDesc")).setClass("obs-git-publisher-textarea").addTextArea((textArea) => {
      textArea.setPlaceholder("docs/assets/js, docs/assets/logo").setValue(this.plugin.settings.autoCleanUpExcluded.join(", ")).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.autoCleanUpExcluded = value.split(/[,\n]\W*/).map((item) => item.trim());
        yield this.plugin.saveSettings();
      }));
    });
    autoCleanUpSettingsOnCondition(condition, autoCleanSetting, this.plugin);
    shortcutsHideShow(this.plugin.settings.autoCleanUp, autoCleanExcludedSettings);
    folderHideShowSettings(frontmatterKeySettings, rootFolderSettings, autoCleanSetting, this.plugin.settings.downloadedFolder, this.plugin, subFolderSettings).then();
  }
  renderTextConversion() {
    this.settingsPage.createEl("p", {
      text: settings("textConversion", "textConversionDesc")
    });
    this.settingsPage.createEl("h5", {
      text: settings("textConversion", "textHeader")
    });
    new import_obsidian2.Setting(this.settingsPage).setName(settings("textConversion", "hardBreakTitle")).setDesc(settings("textConversion", "hardBreakDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.hardBreak).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.hardBreak = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(this.settingsPage).setName(subSettings("textConversion.dataview.header")).setDesc(subSettings("textConversion.dataview.desc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.convertDataview).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.convertDataview = value;
        yield this.plugin.saveSettings();
      }));
    });
    const censorTextDesc = document.createDocumentFragment();
    censorTextDesc.createEl("p", {
      text: subSettings("textConversion.censor.TextDesc")
    }).createEl("p", {
      text: subSettings("textConversion.censor.TextEmpty")
    });
    const toolTipRegex = subSettings("textConversion.censor.TextFlags") + "\n" + subSettings("textConversion.censor.flags.insensitive") + "\n" + subSettings("textConversion.censor.flags.global") + "\n" + subSettings("textConversion.censor.flags.multiline") + "\n" + subSettings("textConversion.censor.flags.dotAll") + "\n" + subSettings("textConversion.censor.flags.unicode") + "\n" + subSettings("textConversion.censor.flags.sticky");
    const details = this.settingsPage.createEl("details");
    details.createEl("summary", {
      text: subSettings("textConversion.censor.TextHeader")
    }).addClass("obs-git-publisher-summary");
    new import_obsidian2.Setting(details).setClass("obs-git-publisher-censor-desc").setDesc(censorTextDesc).addButton((btn) => {
      btn.setIcon("plus").setTooltip(subSettings("textConversion.censor.ToolTipAdd")).onClick(() => __async(this, null, function* () {
        const censorText = {
          entry: "",
          replace: "",
          after: false,
          flags: "gi"
        };
        this.plugin.settings.censorText.push(censorText);
        yield this.plugin.saveSettings();
        this.settingsPage.empty();
        this.renderTextConversion();
        openDetails(subSettings("textConversion.censor.TextHeader"), true);
      }));
    });
    for (const censorText of this.plugin.settings.censorText) {
      const afterIcon = censorText.after ? "double-down-arrow-glyph" : "double-up-arrow-glyph";
      const afterDesc = censorText.after ? subSettings("textConversion.censor.After") : subSettings("textConversion.censor.Before");
      new import_obsidian2.Setting(details).setClass("obs-git-publisher-censor-entry").addText((text) => {
        text.setPlaceholder(subSettings("textConversion.censor.PlaceHolder")).setValue(censorText.entry).onChange((value) => __async(this, null, function* () {
          censorText.entry = value;
          yield this.plugin.saveSettings();
        }));
      }).addText((text) => {
        text.setPlaceholder(subSettings("textConversion.censor.ValuePlaceHolder")).setValue(censorText.replace).onChange((value) => __async(this, null, function* () {
          censorText.replace = value;
          yield this.plugin.saveSettings();
        }));
      }).addButton((btn) => {
        btn.setTooltip(toolTipRegex).setIcon("tags").setClass("obs-git-publisher-censor-flags");
      }).addText((text) => {
        text.setPlaceholder("flags").setValue(censorText.flags).onChange((value) => __async(this, null, function* () {
          if (value.match(/^[gimsuy\s]+$/) || value === "") {
            censorText.flags = value;
            yield this.plugin.saveSettings();
          } else {
            new import_obsidian2.Notice(subSettings("textConversion.censor.flags.error")(value));
          }
        }));
      }).addExtraButton((btn) => {
        btn.setIcon("trash").setTooltip(subSettings("textConversion.censor.ToolTipRemove")).onClick(() => __async(this, null, function* () {
          this.plugin.settings.censorText.splice(this.plugin.settings.censorText.indexOf(censorText), 1);
          yield this.plugin.saveSettings();
          this.settingsPage.empty();
          this.renderTextConversion();
          openDetails(subSettings("textConversion.censor.TextHeader"), true);
        }));
      }).addExtraButton((btn) => {
        btn.setIcon(afterIcon).setTooltip(afterDesc).onClick(() => __async(this, null, function* () {
          censorText.after = !censorText.after;
          yield this.plugin.saveSettings();
          this.settingsPage.empty();
          this.renderTextConversion();
          openDetails(subSettings("textConversion.censor.TextHeader"), true);
        }));
      });
    }
    this.settingsPage.createEl("h5", { text: "Tags" });
    new import_obsidian2.Setting(this.settingsPage).setName(subSettings("textConversion.tags.inlineTagsHeader")).setDesc(subSettings("textConversion.tags.inlineTagsDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.inlineTags).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.inlineTags = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(this.settingsPage).setName(subSettings("textConversion.tags.header")).setDesc(subSettings("textConversion.tags.desc")).setClass("obs-git-publisher-textarea").addTextArea((text) => {
      text.setPlaceholder("field_name").setValue(this.plugin.settings.dataviewFields.join(",")).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.dataviewFields = value.split(/[,\n]\W*/).map((field) => field.trim());
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(this.settingsPage).setName(subSettings("textConversion.tags.ExcludeHeader")).setDesc(subSettings("textConversion.tags.ExcludeDesc")).setClass("obs-git-publisher-textarea").addTextArea((text) => {
      text.setPlaceholder("field value").setValue(this.plugin.settings.excludeDataviewValue.join(",")).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.excludeDataviewValue = value.split(/[,\n]\W*/).map((field) => field.trim());
        yield this.plugin.saveSettings();
      }));
    });
    this.settingsPage.createEl("h5", {
      text: subSettings("textConversion.links.header")
    });
    this.settingsPage.createEl("p", {
      text: subSettings("textConversion.links.desc")
    });
    const folderNoteSettings = new import_obsidian2.Setting(this.settingsPage).setName(subSettings("textConversion.links.folderNote")).setClass("obs-git-publisher").setDesc(subSettings("textConversion.links.folderNoteDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.folderNote).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.folderNote = value;
        yield this.plugin.saveSettings();
      }));
    });
    this.plugin.settings.downloadedFolder === "fixed" /* fixed */ ? hideSettings(folderNoteSettings) : showSettings(folderNoteSettings);
    new import_obsidian2.Setting(this.settingsPage).setName(subSettings("textConversion.links.internals")).setDesc(subSettings("textConversion.links.internalsDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.convertForGithub).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.convertForGithub = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(this.settingsPage).setName(subSettings("textConversion.links.wikilinks")).setDesc(subSettings("textConversion.links.wikilinksDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.convertWikiLinks).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.convertWikiLinks = value;
        yield this.plugin.saveSettings();
      }));
    });
  }
  renderEmbedConfiguration() {
    new import_obsidian2.Setting(this.settingsPage).setName(settings("embed", "transferImage")).setDesc(settings("embed", "transferImageDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.embedImage).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.embedImage = value;
        shortcutsHideShow(value, settingsDefaultImage);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(this.settingsPage).setName(settings("embed", "transferMetaFile")).setDesc(settings("embed", "transferMetaFileDesc")).setClass("obs-git-publisher-textarea").addTextArea((text) => {
      text.setPlaceholder("banner").setValue(this.plugin.settings.metadataFileFields.join(", ")).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.metadataFileFields = value.split(/[,\n]\W*/).map((field) => field.trim());
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(this.settingsPage).setName(settings("embed", "transferEmbeddedNotes")).setDesc(settings("embed", "transferEmbeddedNotesDesc")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.embedNotes).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.embedNotes = value;
        yield this.plugin.saveSettings();
      }));
    });
    const settingsDefaultImage = new import_obsidian2.Setting(this.settingsPage).setName(settings("embed", "defaultImageFolder")).setDesc(settings("embed", "defaultImageFolderDesc")).addText((text) => {
      text.setPlaceholder("docs/images").setValue(this.plugin.settings.defaultImageFolder).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.defaultImageFolder = value.replace(/\/$/, "");
        yield this.plugin.saveSettings();
      }));
    });
  }
  renderPluginSettings() {
    new import_obsidian2.Setting(this.settingsPage).setName(settings("plugin", "shareKey")).setDesc(settings("plugin", "shareKeyDesc")).addText((text) => text.setPlaceholder("share").setValue(this.plugin.settings.shareKey).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.shareKey = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.settingsPage).setName(settings("plugin", "excludedFolder")).setDesc(settings("plugin", "excludedFolderDesc")).setClass("obs-git-publisher-textarea").addTextArea((textArea) => textArea.setPlaceholder("_assets, Archive").setValue(this.plugin.settings.ExcludedFolder).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ExcludedFolder = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.settingsPage).setName(settings("plugin", "fileMenu")).setDesc(settings("plugin", "fileMenuDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.fileMenu).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.fileMenu = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.settingsPage).setName(settings("plugin", "editorMenu")).setDesc(settings("plugin", "editorMenuDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.editorMenu).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.editorMenu = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.settingsPage).setName(settings("plugin", "shareExternalModifiedTitle")).setDesc(settings("plugin", "shareExternalModifiedDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.shareExternalModified).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.shareExternalModified = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.settingsPage).setName(subSettings("plugin.copyLink.copylinkSetting")).setDesc(subSettings("plugin.copyLink.copylinkDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.copyLink).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.copyLink = value;
      shortcutsHideShow(value, baseLinkSettings);
      shortcutsHideShow(value, pathRemover);
      yield this.plugin.saveSettings();
    })));
    const baseLinkSettings = new import_obsidian2.Setting(this.settingsPage).setName(subSettings("plugin.copyLink.baselink")).setDesc(subSettings("plugin.copyLink.baselinkDesc")).setClass("obs-git-publisher").addText((text) => {
      text.setPlaceholder("my_blog.com").setValue(this.plugin.settings.mainLink).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.mainLink = value;
        yield this.plugin.saveSettings();
      }));
    });
    const pathRemover = new import_obsidian2.Setting(this.settingsPage).setName(subSettings("plugin.copyLink.linkpathremover")).setDesc(subSettings("plugin.copyLink.linkpathremoverDesc")).setClass("obs-git-publisher").addText((text) => {
      text.setPlaceholder("docs").setValue(this.plugin.settings.linkRemover).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.linkRemover = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian2.Setting(this.settingsPage).setName(settings("plugin", "logNoticeHeader")).setDesc(settings("plugin", "logNoticeDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.logNotice).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.logNotice = value;
      yield this.plugin.saveSettings();
    })));
    shortcutsHideShow(this.plugin.settings.copyLink, baseLinkSettings);
    shortcutsHideShow(this.plugin.settings.copyLink, pathRemover);
  }
  renderHelp() {
    this.settingsPage.createEl("h2", { text: subSettings("help.usefulLinks.title") });
    console.log(subSettings("help.usefulLinks.title"));
    this.settingsPage.appendChild(usefullLinks());
    this.settingsPage.createEl("hr");
    this.settingsPage.createEl("h2", { text: subSettings("help.frontmatter.title") });
    this.settingsPage.createEl("p", { text: subSettings("help.frontmatter.desc") });
    const yamlKeysUsefullBasedOnYourSettings = `${this.plugin.settings.shareKey}: true
links:
  mdlinks: ${this.plugin.settings.convertWikiLinks}
  convert: true
embed:
  send: ${this.plugin.settings.embedNotes}
  remove: false
attachment:
  send: ${this.plugin.settings.embedImage}
  folder: ${this.plugin.settings.defaultImageFolder}
dataview: ${this.plugin.settings.convertDataview}
hardBreak: ${this.plugin.settings.hardBreak}
repo:
  owner: ${this.plugin.settings.githubName}
  repo: ${this.plugin.settings.githubRepo}
  branch: ${this.plugin.settings.githubBranch}
autoclean: ${this.plugin.settings.autoCleanUp}
baseLink: ${this.plugin.settings.mainLink}`;
    this.settingsPage.createEl("pre", { cls: "language-yaml" }).createEl("code", { text: yamlKeysUsefullBasedOnYourSettings, cls: "language-yaml" });
    this.settingsPage.appendChild(help(this.plugin.settings));
    this.settingsPage.createEl("h2", { text: subSettings("help.multiRepoHelp.title") });
    this.settingsPage.appendChild(multipleRepoExplained(this.plugin.settings));
    this.settingsPage.appendChild(supportMe());
  }
};

// plugin/src/utils.ts
var import_obsidian4 = require("obsidian");

// plugin/contents_conversion/filePathConvertor.ts
var import_obsidian3 = require("obsidian");
function getDataviewPath(markdown, settings2, vault) {
  if (!settings2.convertDataview) {
    return [];
  }
  const wikiRegex = /\[\[(.*?)\]\]/gmi;
  const wikiMatches = markdown.matchAll(wikiRegex);
  const linkedFiles = [];
  if (!wikiMatches)
    return [];
  if (wikiMatches) {
    for (const wikiMatch of wikiMatches) {
      const altText = wikiMatch[1].replace(/(.*)\\?\|/i, "");
      const linkFrom = wikiMatch[1].replace(/\\?\|(.*)/, "");
      const linked = vault.getAbstractFileByPath(linkFrom) instanceof import_obsidian3.TFile ? vault.getAbstractFileByPath(linkFrom) : null;
      if (linked) {
        linkedFiles.push({
          linked,
          linkFrom,
          altText
        });
      }
    }
  }
  return linkedFiles;
}
function createRelativePath(sourceFile, targetFile, metadata, settings2, vault, frontmatter) {
  const sourcePath = getReceiptFolder(sourceFile, settings2, metadata, vault);
  if (targetFile.linked.extension === "md" && (!frontmatter || !frontmatter[settings2.shareKey] || frontmatter[settings2.shareKey] === false)) {
    return targetFile.altText;
  }
  if (targetFile.linked.path === sourceFile.path) {
    return getReceiptFolder(targetFile.linked, settings2, metadata, vault).split("/").at(-1);
  }
  const targetPath = targetFile.linked.extension === "md" ? getReceiptFolder(targetFile.linked, settings2, metadata, vault) : getImageLinkOptions(targetFile.linked, settings2, getFrontmatterCondition(frontmatter, settings2));
  const sourceList = sourcePath.split("/");
  const targetList = targetPath.split("/");
  const excludeUtilDiff = (sourceList2, targetList2) => {
    let i = 0;
    while (sourceList2[i] === targetList2[i]) {
      i++;
    }
    return sourceList2.slice(i);
  };
  const diffSourcePath = excludeUtilDiff(sourceList, targetList);
  const diffTargetPath = excludeUtilDiff(targetList, sourceList);
  const diffTarget = function(folderPath) {
    const relativePath2 = [];
    for (const folder of folderPath) {
      if (folder != folderPath.at(-1)) {
        relativePath2.push("..");
      }
    }
    return relativePath2;
  };
  const relativePath = diffTarget(diffSourcePath);
  if (relativePath.length === 0) {
    relativePath.push(".");
  }
  let relative = relativePath.concat(diffTargetPath).join("/");
  if (relative.trim() === "." || relative.trim() === "") {
    relative = getReceiptFolder(targetFile.linked, settings2, metadata, vault).split("/").at(-1);
  }
  return relative;
}
function folderNoteIndexOBS(file, vault, settings2) {
  if (!settings2.folderNote)
    return file.name;
  const fileName = file.name.replace(".md", "");
  const folderParent = file.parent.name;
  if (fileName === folderParent)
    return "index.md";
  const outsideFolder = vault.getAbstractFileByPath(file.path.replace(".md", ""));
  if (outsideFolder && outsideFolder instanceof import_obsidian3.TFolder)
    return "index.md";
  return file.name;
}
function createObsidianPath(file, settings2, vault, fileName) {
  const folderDefault = settings2.folderDefaultName;
  fileName = folderNoteIndexOBS(file, vault, settings2);
  const rootFolder = folderDefault.length > 0 ? folderDefault + "/" : "";
  const path = rootFolder + file.path.replace(file.name, fileName);
  if (settings2.subFolder.length > 0) {
    return path.replace(settings2.subFolder + "/", "");
  }
  return path;
}
function folderNoteIndexYAML(fileName, frontmatter, settings2) {
  const category = frontmatter[settings2.yamlFolderKey];
  const parentCatFolder = !category.endsWith("/") ? category.split("/").at(-1) : category.split("/").at(-2);
  if (!settings2.folderNote)
    return fileName;
  if (fileName.replace(".md", "").toLowerCase() === parentCatFolder.toLowerCase())
    return "index.md";
  return fileName;
}
function createFrontmatterPath(file, settings2, frontmatter, fileName) {
  let path = settings2.folderDefaultName.length > 0 ? settings2.folderDefaultName + "/" + fileName : fileName;
  let folderRoot = settings2.rootFolder;
  if (folderRoot.length > 0) {
    folderRoot = folderRoot + "/";
  }
  if (frontmatter && frontmatter[settings2.yamlFolderKey]) {
    path = folderRoot + frontmatter[settings2.yamlFolderKey] + "/" + folderNoteIndexYAML(fileName, frontmatter, settings2);
  }
  return path;
}
function getTitleField(frontmatter, file, settings2) {
  if (!settings2.useFrontmatterTitle || !frontmatter) {
    return file.name;
  } else if (frontmatter && frontmatter[settings2.frontmatterTitleKey] && frontmatter[settings2.frontmatterTitleKey] !== file.name) {
    return frontmatter[settings2.frontmatterTitleKey] + ".md";
  }
  return file.name;
}
function getReceiptFolder(file, settings2, metadataCache, vault) {
  var _a;
  if (file.extension === "md") {
    const frontmatter = (_a = metadataCache.getCache(file.path)) == null ? void 0 : _a.frontmatter;
    const fileName = getTitleField(frontmatter, file, settings2);
    if (!frontmatter || frontmatter[settings2.shareKey] === void 0 || !frontmatter[settings2.shareKey]) {
      return fileName;
    }
    let path = settings2.folderDefaultName.length > 0 ? settings2.folderDefaultName + "/" + fileName : fileName;
    if (settings2.downloadedFolder === "yaml" /* yaml */) {
      path = createFrontmatterPath(file, settings2, frontmatter, fileName);
    } else if (settings2.downloadedFolder === "obsidian" /* obsidian */) {
      path = createObsidianPath(file, settings2, vault, fileName);
    }
    return path;
  }
}
function getImageLinkOptions(file, settings2, sourceFrontmatter) {
  if (!sourceFrontmatter) {
    if (settings2.defaultImageFolder.length > 0) {
      return settings2.defaultImageFolder + "/" + file.name;
    } else if (settings2.folderDefaultName.length > 0) {
      return settings2.folderDefaultName + "/" + file.name;
    } else {
      return file.path;
    }
  } else if (sourceFrontmatter && sourceFrontmatter.attachmentLinks !== void 0) {
    return sourceFrontmatter.attachmentLinks + "/" + file.name;
  }
  return file.path;
}

// plugin/src/utils.ts
function noticeLog(message, settings2) {
  if (settings2.logNotice) {
    new import_obsidian4.Notice(message);
  } else {
    console.log(message);
  }
}
function disablePublish(app2, settings2, file) {
  const fileCache = app2.metadataCache.getFileCache(file);
  const meta = fileCache == null ? void 0 : fileCache.frontmatter;
  const folderList = settings2.ExcludedFolder.split(",").filter((x) => x !== "");
  if (meta === void 0) {
    return false;
  } else if (folderList.length > 0) {
    for (let i = 0; i < folderList.length; i++) {
      if (file.path.contains(folderList[i].trim())) {
        return false;
      }
    }
  }
  return meta[settings2.shareKey];
}
function checkSlash(link) {
  const slash = link.match(/\/*$/);
  if (slash[0].length != 1) {
    link = link.replace(/\/*$/, "") + "/";
  }
  return link;
}
function createLink(file, repo, metadataCache, vault, settings2) {
  return __async(this, null, function* () {
    var _a;
    if (!settings2.copyLink) {
      return;
    }
    let filepath = getReceiptFolder(file, settings2, metadataCache, vault);
    let baseLink = settings2.mainLink;
    if (baseLink.length === 0) {
      if (repo instanceof Array) {
        baseLink = `https://${settings2.githubName}.github.io/${settings2.githubRepo}/`;
      } else {
        baseLink = `https://${repo.owner}.github.io/${repo.repo}/`;
      }
    }
    const keyRepo = (_a = metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter["baselink"];
    if (keyRepo !== void 0) {
      baseLink = keyRepo;
    }
    baseLink = checkSlash(baseLink);
    if (settings2.linkRemover.length > 0) {
      const tobeRemoved = settings2.linkRemover.split(",");
      for (const part of tobeRemoved) {
        if (part.length > 0) {
          filepath = filepath.replace(part.trim(), "");
        }
      }
    }
    const url = encodeURI(baseLink + filepath.replace(".md", ""));
    yield navigator.clipboard.writeText(url);
    return;
  });
}
function noticeMessage(PublisherManager, file, settings2, repo) {
  return __async(this, null, function* () {
    if (repo instanceof Array) {
      for (const repository of repo) {
        yield noticeMessageOneRepo(PublisherManager, file, settings2, repository);
      }
    } else {
      noticeMessageOneRepo(PublisherManager, file, settings2, repo);
    }
  });
}
function noticeMessageOneRepo(PublisherManager, file, settings2, repo) {
  return __async(this, null, function* () {
    const noticeValue = file instanceof import_obsidian4.TFile ? '"' + file.basename + '"' : file;
    if (settings2.workflowName.length > 0) {
      new import_obsidian4.Notice(informations("sendMessage")([noticeValue, repo.owner + ":" + repo.repo, `.
${informations("waitingWorkflow")}`]));
      const successWorkflow = yield PublisherManager.workflowGestion(repo);
      if (successWorkflow) {
        new import_obsidian4.Notice(informations("successfullPublish")([noticeValue, repo.owner + ":" + repo.repo]));
      }
    } else {
      new import_obsidian4.Notice(informations("successfullPublish")([noticeValue, repo.owner + ":" + repo.repo]));
    }
  });
}
function trimObject(obj) {
  const trimmed = JSON.stringify(obj, (key, value) => {
    if (typeof value === "string") {
      return value.trim().toLowerCase();
    }
    return value;
  });
  return JSON.parse(trimmed);
}
function isAttachment(filename) {
  return filename.match(/(png|jpe?g|gif|bmp|svg|mp[34]|web[mp]|wav|m4a|ogg|3gp|flac|ogv|mov|mkv|pdf)$/i);
}
function getFrontmatterCondition(frontmatter, settings2) {
  let imageDefaultFolder = null;
  if (settings2.defaultImageFolder.length > 0) {
    imageDefaultFolder = settings2.defaultImageFolder;
  } else if (settings2.folderDefaultName.length > 0) {
    imageDefaultFolder = settings2.folderDefaultName;
  }
  const settingsConversion = {
    convertWiki: settings2.convertWikiLinks,
    attachment: settings2.embedImage,
    embed: settings2.embedNotes,
    attachmentLinks: imageDefaultFolder,
    links: true,
    removeEmbed: false,
    dataview: settings2.convertDataview,
    hardbreak: settings2.hardBreak
  };
  if (frontmatter.links !== void 0) {
    if (typeof frontmatter.links === "object") {
      if (frontmatter.links.convert !== void 0) {
        settingsConversion.links = frontmatter.links.convert;
      }
      if (frontmatter.links.internals !== void 0) {
        settingsConversion.links = frontmatter.links.internals;
      }
      if (frontmatter.links.mdlinks !== void 0) {
        settingsConversion.convertWiki = frontmatter.links.mdlinks;
      }
    } else {
      settingsConversion.links = frontmatter.links;
    }
  }
  if (frontmatter.embed !== void 0) {
    if (typeof frontmatter.embed === "object") {
      if (frontmatter.embed.send !== void 0) {
        settingsConversion.embed = frontmatter.embed.send;
      }
      if (frontmatter.embed.remove !== void 0) {
        settingsConversion.removeEmbed = frontmatter.embed.remove;
      }
    } else {
      settingsConversion.embed = frontmatter.embed;
    }
  }
  if (frontmatter.attachment !== void 0) {
    if (typeof frontmatter.attachment === "object") {
      if (frontmatter.attachment.send !== void 0) {
        settingsConversion.attachment = frontmatter.attachment.send;
      }
      if (frontmatter.attachment.folder !== void 0) {
        settingsConversion.attachmentLinks = frontmatter.attachment.folder;
      }
    } else {
      settingsConversion.attachment = frontmatter.attachment;
    }
  }
  if (frontmatter.attachmentLinks !== void 0) {
    settingsConversion.attachmentLinks = frontmatter.attachmentLinks.toString().replace(/\/$/, "");
  }
  if (frontmatter.mdlinks !== void 0) {
    settingsConversion.convertWiki = frontmatter.mdlinks;
  }
  if (frontmatter.removeEmbed !== void 0) {
    settingsConversion.removeEmbed = frontmatter.removeEmbed;
  }
  if (frontmatter.dataview !== void 0) {
    settingsConversion.dataview = frontmatter.dataview;
  }
  if (frontmatter.hardbreak !== void 0) {
    settingsConversion.hardbreak = frontmatter.hardbreak;
  }
  return settingsConversion;
}
function getRepoFrontmatter(settings2, frontmatter) {
  let repoFrontmatter = {
    branch: settings2.githubBranch,
    repo: settings2.githubRepo,
    owner: settings2.githubName,
    autoclean: settings2.autoCleanUp
  };
  if (!frontmatter) {
    return repoFrontmatter;
  }
  if (frontmatter.multipleRepo !== void 0) {
    const multipleRepo = parseMultipleRepo(frontmatter, repoFrontmatter);
    if (multipleRepo.length === 1) {
      return multipleRepo[0];
    }
    return multipleRepo;
  } else if (frontmatter.repo !== void 0) {
    if (typeof frontmatter.repo === "object") {
      if (frontmatter.repo.branch !== void 0) {
        repoFrontmatter.branch = frontmatter.repo.branch;
      }
      if (frontmatter.repo.repo !== void 0) {
        repoFrontmatter.repo = frontmatter.repo.repo;
      }
      if (frontmatter.repo.owner !== void 0) {
        repoFrontmatter.owner = frontmatter.repo.owner;
      }
    } else {
      const repo = frontmatter.repo.split("/");
      repoFrontmatter = repositoryStringSlice(repo, repoFrontmatter);
    }
  }
  if (frontmatter.autoclean !== void 0) {
    repoFrontmatter.autoclean = frontmatter.autoclean;
  }
  return repoFrontmatter;
}
function parseMultipleRepo(frontmatter, repoFrontmatter) {
  const multipleRepo = [];
  if (frontmatter.multipleRepo instanceof Array && frontmatter.multipleRepo.length > 0) {
    for (const repo of frontmatter.multipleRepo) {
      if (typeof repo === "object") {
        const repository = {
          branch: repoFrontmatter.branch,
          repo: repoFrontmatter.repo,
          owner: repoFrontmatter.owner,
          autoclean: false
        };
        if (repo.branch !== void 0) {
          repository.branch = repo.branch;
        }
        if (repo.repo !== void 0) {
          repository.repo = repo.repo;
        }
        if (repo.owner !== void 0) {
          repository.owner = repo.owner;
        }
        if (repo.autoclean !== void 0) {
          repository.autoclean = repo.autoclean;
        }
        multipleRepo.push(repository);
      } else {
        const repoString = repo.split("/");
        const repository = {
          branch: repoFrontmatter.branch,
          repo: repoFrontmatter.repo,
          owner: repoFrontmatter.owner,
          autoclean: false
        };
        multipleRepo.push(repositoryStringSlice(repoString, repository));
      }
    }
  }
  return multipleRepo;
}
function repositoryStringSlice(repo, repoFrontmatter) {
  const newRepo = {
    branch: repoFrontmatter.branch,
    repo: repoFrontmatter.repo,
    owner: repoFrontmatter.owner,
    autoclean: false
  };
  if (repo.length >= 4) {
    newRepo.branch = repo[2];
    newRepo.repo = repo[1];
    newRepo.owner = repo[0];
    newRepo.autoclean = repo[3] === "true";
  }
  if (repo.length === 3) {
    newRepo.branch = repo[2];
    newRepo.repo = repo[1];
    newRepo.owner = repo[0];
  } else if (repo.length === 2) {
    newRepo.repo = repo[1];
    newRepo.owner = repo[0];
  } else if (repo.length === 1) {
    newRepo.repo = repo[0];
  }
  return newRepo;
}

// plugin/publishing/filesManagement.ts
var import_obsidian8 = require("obsidian");

// plugin/publishing/upload.ts
var import_obsidian7 = require("obsidian");

// node_modules/js-base64/base64.mjs
var version = "3.7.2";
var VERSION = version;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI2 = (src) => encode(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a), (c) => c.charCodeAt(0));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// plugin/publishing/delete.ts
var import_obsidian5 = require("obsidian");
function deleteFromGithub(silent = false, settings2, octokit, branchName = "main", filesManagement, repoFrontmatter) {
  return __async(this, null, function* () {
    if (repoFrontmatter instanceof Array) {
      for (const repo of repoFrontmatter) {
        yield deleteFromGithubOneRepo(silent, settings2, octokit, branchName, filesManagement, repo);
      }
    } else {
      yield deleteFromGithubOneRepo(silent, settings2, octokit, branchName, filesManagement, repoFrontmatter);
    }
  });
}
function deleteFromGithubOneRepo(silent = false, settings2, octokit, branchName = "main", filesManagement, repo) {
  return __async(this, null, function* () {
    const getAllFile = yield filesManagement.getAllFileFromRepo(branchName, octokit, settings2, repo);
    const filesInRepo = yield filterGithubFile(getAllFile, settings2);
    if (!filesInRepo) {
      let errorMsg = "";
      if (settings2.folderDefaultName.length > 0) {
        if (settings2.folderDefaultName.length > 0) {
          errorMsg = deletion("errorDeleteDefaultFolder");
        } else if (settings2.downloadedFolder === "yaml" /* yaml */ && settings2.rootFolder.length === 0) {
          errorMsg = deletion("errorDeleteRootFolder");
        }
        if (!silent) {
          new import_obsidian5.Notice("Error : " + errorMsg);
        }
      }
      return false;
    }
    const allSharedFiles = filesManagement.getAllFileWithPath();
    const allSharedConverted = allSharedFiles.map((file) => {
      return { converted: file.converted, repo: file.repoFrontmatter };
    });
    let deletedSuccess = 0;
    let deletedFailed = 0;
    for (const file of filesInRepo) {
      const isInObsidian = allSharedConverted.some((f) => f.converted === file.file);
      const isMarkdownForAnotherRepo = file.file.trim().endsWith(".md") ? !allSharedConverted.some((f) => f.converted === file.file && JSON.stringify(f.repo) == JSON.stringify(repo)) : false;
      const isNeedToBeDeleted = isInObsidian ? isMarkdownForAnotherRepo : true;
      if (isNeedToBeDeleted) {
        const checkingIndex = file.file.contains("index") ? yield checkIndexFiles(octokit, settings2, file.file, repo) : false;
        try {
          if (!checkingIndex) {
            noticeLog(`trying to delete file : ${file.file} from ${repo.owner}/${repo.repo}`, settings2);
            const reponse = yield octokit.request("DELETE /repos/{owner}/{repo}/contents/{path}", {
              owner: repo.owner,
              repo: repo.repo,
              path: file.file,
              message: "Delete file",
              sha: file.sha,
              branch: branchName
            });
            if (reponse.status === 200) {
              deletedSuccess++;
            } else {
              deletedFailed++;
            }
          }
        } catch (e) {
          if (!(e instanceof DOMException))
            noticeLog(e, settings2);
        }
      }
    }
    let successMsg = deletion("noFileDeleted");
    let failedMsg = "";
    if (deletedSuccess > 0) {
      successMsg = deletion("successDeleting")(deletedSuccess.toString());
    }
    if (deletedFailed > 0) {
      failedMsg = deletion("failedDeleting")(deletedFailed.toString());
    }
    if (!silent) {
      new import_obsidian5.Notice(successMsg + failedMsg);
    }
    return true;
  });
}
function excludedFileFromDelete(file, settings2) {
  const autoCleanExcluded = settings2.autoCleanUpExcluded;
  if (autoCleanExcluded.length > 0) {
    for (const excludedFile of autoCleanExcluded) {
      if (file.trim().includes(excludedFile.trim()) && excludedFile.length > 0) {
        return true;
      }
    }
  }
  return false;
}
function filterGithubFile(fileInRepo, settings2) {
  return __async(this, null, function* () {
    const sharedFilesInRepo = [];
    for (const file of fileInRepo) {
      if (settings2.downloadedFolder === "yaml" /* yaml */ && settings2.rootFolder.length === 0 || settings2.folderDefaultName.length === 0) {
        return null;
      }
      if ((file.file.includes(settings2.folderDefaultName) || settings2.downloadedFolder === "yaml" /* yaml */ && file.file.includes(settings2.rootFolder) || settings2.defaultImageFolder.length > 0 && file.file.includes(settings2.defaultImageFolder)) && !excludedFileFromDelete(file.file, settings2) && (isAttachment(file.file) || file.file.match("md$"))) {
        sharedFilesInRepo.push(file);
      }
    }
    return sharedFilesInRepo;
  });
}
function parseYamlFrontmatter(contents) {
  const yamlFrontmatter = contents.split("---")[1];
  const yamlFrontmatterParsed = (0, import_obsidian5.parseYaml)(yamlFrontmatter);
  return trimObject(yamlFrontmatterParsed);
}
function checkIndexFiles(octokit, settings2, path, repoFrontmatter) {
  return __async(this, null, function* () {
    try {
      const fileRequest = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
        owner: repoFrontmatter.owner,
        repo: repoFrontmatter.repo,
        path
      });
      if (fileRequest.status === 200) {
        const fileContent = gBase64.decode(fileRequest.data.content);
        const fileFrontmatter = parseYamlFrontmatter(fileContent);
        return fileFrontmatter.index === "true" || fileFrontmatter.autoclean === "false" || !fileFrontmatter.share;
      }
    } catch (e) {
      if (!(e instanceof DOMException)) {
        noticeLog(e, settings2);
        return false;
      }
    }
  });
}

// plugin/src/status_bar.ts
var ShareStatusBar = class {
  constructor(statusBarItem, numberOfNotesToPublish, attachment = false) {
    this.attachment = false;
    this.statusBarItem = statusBarItem;
    this.counter = 0;
    this.numberOfNotesToPublish = numberOfNotesToPublish;
    this.attachment = attachment;
    this.statusBarItem.createEl("span", { text: "" });
    let msg = `${this.numberOfNotesToPublish} files marked for sharing`;
    if (this.attachment) {
      msg = `${this.numberOfNotesToPublish} attachments linked`;
    }
    this.status = this.statusBarItem.createEl("span", { text: `${msg}` });
  }
  increment() {
    let msg = `\u231BSharing files`;
    if (this.attachment) {
      msg = `\u231BSharing attachments`;
    }
    this.status.setText(`${msg}: ${++this.counter}/${this.numberOfNotesToPublish}`);
  }
  finish(displayDurationMillisec) {
    let msg = `\u2705 Published files`;
    if (this.attachment) {
      msg = `\u2705 Shared attachments`;
    }
    this.status.setText(`${msg}: ${this.counter}/${this.numberOfNotesToPublish}`);
    setTimeout(() => {
      this.statusBarItem.remove();
    }, displayDurationMillisec);
  }
  error() {
    this.statusBarItem.remove();
  }
};

// plugin/contents_conversion/convertText.ts
var import_obsidian6 = require("obsidian");
var import_obsidian_dataview = __toESM(require_lib());

// plugin/contents_conversion/convertLinks.ts
function convertWikilinks(fileContent, conditionConvert, settings2, linkedFiles) {
  const convertWikilink = conditionConvert.convertWiki;
  const imageSettings = conditionConvert.attachment;
  const embedSettings = conditionConvert.embed;
  const convertLinks = conditionConvert.links;
  if (!convertWikilink && convertLinks && imageSettings && embedSettings && !conditionConvert.removeEmbed) {
    return fileContent;
  }
  const wikiRegex = /!?\[\[.*?\]\]/g;
  const wikiMatches = fileContent.match(wikiRegex);
  if (wikiMatches) {
    const fileRegex = /(\[\[).*?([\]|])/;
    for (const wikiMatch of wikiMatches) {
      const fileMatch = wikiMatch.match(fileRegex);
      const isEmbed = wikiMatch.startsWith("!") ? "!" : "";
      const isEmbedBool = wikiMatch.startsWith("!");
      if (fileMatch) {
        let linkCreator = wikiMatch;
        const fileName = fileMatch[0].replaceAll("[", "").replaceAll("|", "").replaceAll("]", "").replaceAll("\\", "");
        const StrictFileName = fileMatch[0].replaceAll("[", "").replaceAll("|", "").replaceAll("]", "").replaceAll("\\", "").replaceAll("../", "").replaceAll("./", "");
        const linkedFile = linkedFiles.find((item) => item.linkFrom === StrictFileName);
        if (linkedFile) {
          const altText = linkedFile.altText.length > 0 ? linkedFile.altText : linkedFile.linked.extension === "md" ? linkedFile.linked.basename : "";
          const removeEmbed = conditionConvert.removeEmbed && isEmbedBool && linkedFile.linked.extension === "md";
          if (convertWikilink) {
            let linkDestination = linkedFile.linkFrom;
            if (linkedFile.destinationFilePath) {
              linkDestination = linkedFile.destinationFilePath;
            }
            linkCreator = `${isEmbed}[${altText}](${encodeURI(linkDestination)})`;
          }
          if (linkedFile.linked.extension === "md" && !convertLinks && !isEmbedBool) {
            linkCreator = altText;
          }
          if (!imageSettings && isAttachment(linkedFile.linked.extension) || removeEmbed) {
            linkCreator = "";
          }
          fileContent = fileContent.replace(wikiMatch, linkCreator);
        } else if (!fileName.startsWith("http")) {
          const altMatch = wikiMatch.match(/(\|).*(]])/);
          const altCreator = fileName.split("/");
          const altLink = creatorAltLink(altMatch, altCreator, fileName.split(".").at(-1), fileName);
          const removeEmbed = !isAttachment(fileName.trim()) && conditionConvert.removeEmbed && isEmbedBool;
          if (convertWikilink) {
            const markdownName = !isAttachment(fileName.trim()) ? fileName.trim() + ".md" : fileName.trim();
            linkCreator = `${isEmbed}[${altLink}](${encodeURI(markdownName)})`;
          }
          if (!isAttachment(fileName.trim()) && !convertLinks && !isEmbedBool) {
            linkCreator = altLink;
          }
          if (!imageSettings && isAttachment(fileName.trim()) || removeEmbed) {
            linkCreator = "";
          }
          fileContent = fileContent.replace(wikiMatch, linkCreator);
        }
      }
    }
  }
  return fileContent;
}
function addAltText(link, linkedFile) {
  if (!link.match(/(\|).*(]])/)) {
    return link.replace("|", "").replace("]]", `|${linkedFile.altText}]]`);
  }
  return link;
}
function convertLinkCitation(fileContent, settings2, linkedFiles, metadataCache, sourceFile, vault, frontmatter) {
  if (!settings2.convertForGithub) {
    return fileContent;
  }
  for (const linkedFile of linkedFiles) {
    let pathInGithub = createRelativePath(sourceFile, linkedFile, metadataCache, settings2, vault, frontmatter).replace(".md", "");
    const regexToReplace = new RegExp(`(\\[{2}${linkedFile.linkFrom}(\\\\?\\|.*)?\\]{2})|(\\[.*\\]\\(${linkedFile.linkFrom}\\))`, "g");
    const matchedLink = fileContent.match(regexToReplace);
    if (matchedLink) {
      for (const link of matchedLink) {
        const regToReplace = new RegExp(`${linkedFile.linkFrom}`);
        const block_link = linkedFile.linkFrom.match(/#.*/);
        if (block_link) {
          pathInGithub += block_link[0];
        }
        let newLink = link.replace(regToReplace, pathInGithub);
        newLink = addAltText(newLink, linkedFile);
        fileContent = fileContent.replace(link, newLink);
      }
    }
  }
  return fileContent;
}
function creatorAltLink(altMatch, altCreator, fileExtension, match) {
  if (altMatch) {
    return altMatch[0].replace("]]", "").replace("|", "");
  }
  if (fileExtension === "md") {
    return altCreator.length > 1 ? altCreator[altCreator.length - 1] : altCreator[0];
  }
  return match.split("/").at(-1);
}

// plugin/contents_conversion/findAndReplaceText.ts
function findAndReplaceText(text, settings2, after) {
  if (!settings2.censorText) {
    return text;
  }
  let censoring = settings2.censorText.filter((censor) => !censor.after);
  if (after) {
    censoring = settings2.censorText.filter((censor) => censor.after);
  }
  for (const censor of censoring) {
    if (!censor.flags || !censor.flags.match(/^[gimsuy\s]+$/)) {
      censor.flags = "gi";
    }
    const regex = new RegExp(censor.entry, censor.flags);
    text = text.replaceAll(regex, censor.replace);
  }
  return text;
}

// plugin/contents_conversion/convertText.ts
function addHardLineBreak(text, settings2, frontmatter) {
  try {
    text = text.replace(/^\s*\\\s*$/gmi, "<br/>");
    if (frontmatter.hardbreak) {
      text = text.replace(/\n/gm, "  \n");
    }
    return text;
  } catch (e) {
    noticeLog(e, settings2);
    return text;
  }
}
function addTagsToYAML(text, toAdd) {
  return __async(this, null, function* () {
    const yaml = text.split("---")[1];
    const yamlObject = (0, import_obsidian6.parseYaml)(yaml);
    if (yamlObject.tag) {
      toAdd = [.../* @__PURE__ */ new Set([...toAdd, ...yamlObject.tag.map((tag) => tag.replaceAll("/", "_"))])];
      delete yamlObject.tag;
    }
    if (yamlObject.tags) {
      yamlObject.tags = [.../* @__PURE__ */ new Set([...yamlObject.tags.map((tag) => tag.replaceAll("/", "_")), ...toAdd])];
    } else {
      yamlObject.tags = toAdd;
    }
    const returnToYaml = (0, import_obsidian6.stringifyYaml)(yamlObject);
    const fileContentsOnly = text.split("---").slice(2).join("---");
    return `---
${returnToYaml}---
${fileContentsOnly}`;
  });
}
function addInlineTags(settings2, file, metadataCache, app2, frontmatter, text) {
  return __async(this, null, function* () {
    var _a;
    if (!settings2.inlineTags) {
      return text;
    }
    const inlineTags = (_a = metadataCache.getFileCache(file)) == null ? void 0 : _a.tags;
    const inlineTagsInText = inlineTags ? inlineTags.map((t) => t.tag.replace("#", "").replaceAll("/", "_")) : [];
    const frontmatterTags = (0, import_obsidian6.parseFrontMatterTags)(frontmatter);
    const yamlTags = frontmatterTags ? frontmatterTags.map((t) => t.replace("#", "").replaceAll("/", "_")) : [];
    const toAdd = [.../* @__PURE__ */ new Set([...inlineTagsInText, ...yamlTags])];
    if (toAdd.length > 0) {
      return yield addTagsToYAML(text, toAdd);
    }
    return text;
  });
}
function dataviewExtract(fieldValue, settings2) {
  const basename = (name) => /([^/\\.]*)(\..*)?$/.exec(name)[1];
  const filename = basename(fieldValue.path).toString();
  const display = fieldValue.display ? fieldValue.display.toString() : filename;
  if (!settings2.excludeDataviewValue.includes(display) && !settings2.excludeDataviewValue.includes(filename)) {
    return display;
  }
  return null;
}
function convertInlineDataview(text, settings2, sourceFile, app2) {
  return __async(this, null, function* () {
    if (settings2.dataviewFields.length === 0 || !app2.plugins.enabledPlugins.has("dataview")) {
      return text;
    }
    const dvApi = (0, import_obsidian_dataview.getAPI)();
    const dataviewLinks = yield dvApi.page(sourceFile.path);
    const valueToAdd = [];
    for (const field of settings2.dataviewFields) {
      const fieldValue = dataviewLinks[field];
      if (fieldValue) {
        if (fieldValue.constructor.name === "Link") {
          const stringifyField = dataviewExtract(fieldValue, settings2);
          valueToAdd.push(stringifyField);
        } else if (fieldValue.constructor.name === "Array") {
          for (const item of fieldValue) {
            let stringifyField = item;
            if (item.constructor.name === "Link") {
              stringifyField = dataviewExtract(item, settings2);
              valueToAdd.push(stringifyField);
            } else if (!settings2.excludeDataviewValue.includes(stringifyField.toString())) {
              valueToAdd.push(stringifyField.toString());
            }
          }
        } else if (!settings2.excludeDataviewValue.includes(fieldValue.toString())) {
          valueToAdd.push(fieldValue.toString());
        }
      }
    }
    if (valueToAdd.length > 0) {
      return yield addTagsToYAML(text, valueToAdd.filter(Boolean));
    }
    return text;
  });
}
function convertDataviewQueries(text, path, settings2, app2, metadataCache, frontmatterSettings, frontmatter, sourceFile) {
  return __async(this, null, function* () {
    if (!app2.plugins.enabledPlugins.has("dataview")) {
      return text;
    }
    const vault = app2.vault;
    let replacedText = text;
    const dataviewRegex = new RegExp("```dataview(.+?)```", "gsm");
    const dvApi = (0, import_obsidian_dataview.getAPI)();
    const matches = text.matchAll(dataviewRegex);
    if (!matches)
      return;
    const settingsDataview = frontmatterSettings.dataview;
    for (const queryBlock of matches) {
      try {
        const block = queryBlock[0];
        const query = queryBlock[1];
        let md = settingsDataview ? yield dvApi.tryQueryMarkdown(query, path) : "";
        const dataviewPath = getDataviewPath(md, settings2, vault);
        md = convertLinkCitation(md, settings2, dataviewPath, metadataCache, sourceFile, vault, frontmatter);
        md = convertWikilinks(md, frontmatterSettings, settings2, dataviewPath);
        replacedText = replacedText.replace(block, md);
      } catch (e) {
        noticeLog(e, settings2);
        new import_obsidian6.Notice("Unable to render dataview query. Please update the dataview plugin to the last version.");
        return queryBlock[0];
      }
    }
    return replacedText;
  });
}
function mainConverting(text, settings2, frontmatterSettings, file, app2, metadataCache, frontmatter, linkedFiles, plugin, vault) {
  return __async(this, null, function* () {
    text = findAndReplaceText(text, settings2, false);
    text = yield addInlineTags(settings2, file, metadataCache, plugin.app, frontmatter, text);
    text = yield convertDataviewQueries(text, file.path, settings2, plugin.app, metadataCache, frontmatterSettings, frontmatter, file);
    text = yield convertInlineDataview(text, settings2, file, plugin.app);
    text = addHardLineBreak(text, settings2, frontmatterSettings);
    text = convertLinkCitation(text, settings2, linkedFiles, metadataCache, file, vault, frontmatter);
    text = convertWikilinks(text, frontmatterSettings, settings2, linkedFiles);
    text = findAndReplaceText(text, settings2, true);
    return text;
  });
}

// plugin/publishing/upload.ts
var Publisher = class {
  constructor(vault, metadataCache, settings2, octokit, plugin) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.settings = settings2;
    this.octokit = octokit;
    this.plugin = plugin;
  }
  statusBarForEmbed(linkedFiles, fileHistory, ref = "main", deepScan, sourceFrontmatter, repoFrontmatter) {
    return __async(this, null, function* () {
      if (linkedFiles.length > 0) {
        if (linkedFiles.length > 1) {
          const statusBarItems = this.plugin.addStatusBarItem();
          const statusBar = new ShareStatusBar(statusBarItems, linkedFiles.length, true);
          try {
            for (const image of linkedFiles) {
              try {
                if (!fileHistory.includes(image)) {
                  if (image.extension === "md" && deepScan) {
                    yield this.publish(image, false, ref, repoFrontmatter, fileHistory, true);
                  } else if (isAttachment(image.extension) && sourceFrontmatter.attachment) {
                    yield this.uploadImage(image, ref, sourceFrontmatter, repoFrontmatter);
                    fileHistory.push(image);
                  }
                }
                statusBar.increment();
              } catch (e) {
                new import_obsidian7.Notice(error("unablePublishNote")(image.name));
                console.error(e);
              }
            }
            statusBar.finish(8e3);
          } catch (e) {
            noticeLog(e, this.settings);
            new import_obsidian7.Notice(error("errorPublish")(repoFrontmatter.repo));
            statusBar.error();
          }
        } else {
          const embed = linkedFiles[0];
          if (!fileHistory.includes(embed)) {
            if (embed.extension === "md" && deepScan) {
              yield this.publish(embed, false, ref, repoFrontmatter, fileHistory, true);
            } else if (isAttachment(embed.extension) && sourceFrontmatter.attachment) {
              yield this.uploadImage(embed, ref, sourceFrontmatter, repoFrontmatter);
              fileHistory.push(embed);
            }
          }
        }
      }
      return fileHistory;
    });
  }
  publish(_0) {
    return __async(this, arguments, function* (file, autoclean = false, ref = "main", repoFrontmatter, fileHistory = [], deepScan = false) {
      const shareFiles = new FilesManagement(this.vault, this.metadataCache, this.settings, this.octokit, this.plugin);
      const sharedKey = this.settings.shareKey;
      const frontmatter = this.metadataCache.getFileCache(file).frontmatter;
      if (!frontmatter || !frontmatter[sharedKey] || shareFiles.checkExcludedFolder(file) || file.extension !== "md" || fileHistory.includes(file) || JSON.stringify(getRepoFrontmatter(this.settings, frontmatter)) !== JSON.stringify(repoFrontmatter)) {
        return false;
      }
      try {
        noticeLog("Publishing file: " + file.path, this.settings);
        fileHistory.push(file);
        const frontmatterSettings = getFrontmatterCondition(frontmatter, this.settings);
        let embedFiles = shareFiles.getSharedEmbed(file, frontmatterSettings);
        embedFiles = yield shareFiles.getMetadataLinks(file, embedFiles, frontmatter, frontmatterSettings);
        const linkedFiles = shareFiles.getLinkedByEmbedding(file);
        let text = yield app.vault.cachedRead(file);
        text = yield mainConverting(text, this.settings, frontmatterSettings, file, app, this.metadataCache, frontmatter, linkedFiles, this.plugin, this.vault);
        const path = getReceiptFolder(file, this.settings, this.metadataCache, this.vault);
        if (repoFrontmatter instanceof Array) {
          noticeLog("Multiple repo" + repoFrontmatter, this.settings);
          const success = [];
          for (const repo of repoFrontmatter) {
            success.push(yield this.uploadMultiple(file, text, ref, frontmatterSettings, path, repo, embedFiles, fileHistory, deepScan, shareFiles, autoclean));
          }
          return !success.every((value) => value === false);
        } else {
          return yield this.uploadMultiple(file, text, ref, frontmatterSettings, path, repoFrontmatter, embedFiles, fileHistory, deepScan, shareFiles, autoclean);
        }
      } catch (e) {
        noticeLog(e, this.settings);
        return false;
      }
    });
  }
  uploadMultiple(file, text, ref, frontmatterSettings, path, repo, embedFiles, fileHistory, deepScan, shareFiles, autoclean) {
    return __async(this, null, function* () {
      noticeLog(`Upload ${file.name}:${path} on ${repo.owner}/${repo.repo}:${ref}`, this.settings);
      yield this.uploadText(file.path, text, path, file.name, ref, repo);
      yield this.statusBarForEmbed(embedFiles, fileHistory, ref, deepScan, frontmatterSettings, repo);
      if (autoclean && repo.autoclean) {
        yield deleteFromGithub(true, this.settings, this.octokit, ref, shareFiles, repo);
      }
      return true;
    });
  }
  upload(filePath, content, path, title = "", ref = "main", repoFrontmatter) {
    return __async(this, null, function* () {
      if (!repoFrontmatter.repo) {
        new import_obsidian7.Notice("Config error : You need to define a github repo in the plugin settings");
        throw {};
      }
      if (!repoFrontmatter.owner) {
        new import_obsidian7.Notice("Config error : You need to define your github username in the plugin settings");
        throw {};
      }
      const octokit = this.octokit;
      let msg = `PUSH NOTE : ${title}`;
      if (isAttachment(path)) {
        title = path.split("/")[path.split("/").length - 1];
        msg = `PUSH ATTACHMENT : ${title}`;
      }
      const payload = {
        owner: repoFrontmatter.owner,
        repo: repoFrontmatter.repo,
        path,
        message: `Adding ${title}`,
        content,
        sha: "",
        branch: ref
      };
      try {
        const response = yield octokit.request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: repoFrontmatter.owner,
          repo: repoFrontmatter.repo,
          path,
          ref
        });
        if (response.status === 200 && response.data.type === "file") {
          payload.sha = response.data.sha;
        }
      } catch (e) {
        noticeLog("The 404 error is normal ! It means that the file does not exist yet. Don't worry \u2764\uFE0F.", this.settings);
      }
      payload.message = msg;
      yield octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", payload);
    });
  }
  uploadImage(imageFile, ref = "main", sourcefrontmatter, repoFrontmatter) {
    return __async(this, null, function* () {
      const imageBin = yield this.vault.readBinary(imageFile);
      const image64 = (0, import_obsidian7.arrayBufferToBase64)(imageBin);
      const path = getImageLinkOptions(imageFile, this.settings, sourcefrontmatter);
      yield this.upload(imageFile.path, image64, path, "", ref, repoFrontmatter);
    });
  }
  uploadText(filePath, text, path, title = "", ref = "main", repoFrontmatter) {
    return __async(this, null, function* () {
      try {
        const contentBase64 = gBase64.encode(text).toString();
        yield this.upload(filePath, contentBase64, path, title, ref, repoFrontmatter);
      } catch (e) {
        console.error(e);
      }
    });
  }
  workflowGestion(repoFrontmatter) {
    return __async(this, null, function* () {
      let finished = false;
      if (this.settings.workflowName.length === 0) {
        return false;
      } else {
        const octokit = this.octokit;
        yield octokit.request("POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches", {
          owner: repoFrontmatter.owner,
          repo: repoFrontmatter.repo,
          workflow_id: this.settings.workflowName,
          ref: "main"
        });
        while (!finished) {
          yield sleep(1e4);
          const workflowGet = yield octokit.request("GET /repos/{owner}/{repo}/actions/runs", {
            owner: repoFrontmatter.owner,
            repo: repoFrontmatter.repo
          });
          if (workflowGet.data.workflow_runs.length > 0) {
            const build = workflowGet.data.workflow_runs.find((run) => run.name === this.settings.workflowName.replace(".yml", ""));
            if (build.status === "completed") {
              finished = true;
              return true;
            }
          }
        }
      }
    });
  }
};

// plugin/publishing/filesManagement.ts
var import_obsidian_dataview2 = __toESM(require_lib());
var FilesManagement = class extends Publisher {
  constructor(vault, metadataCache, settings2, octokit, plugin) {
    super(vault, metadataCache, settings2, octokit, plugin);
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.settings = settings2;
    this.octokit = octokit;
    this.plugin = plugin;
  }
  getSharedFiles() {
    const files = this.vault.getMarkdownFiles();
    const shared_File = [];
    const sharedkey = this.settings.shareKey;
    for (const file of files) {
      try {
        const frontMatter = this.metadataCache.getCache(file.path).frontmatter;
        if (frontMatter && frontMatter[sharedkey] === true) {
          shared_File.push(file);
        }
      } catch (e) {
      }
    }
    return shared_File;
  }
  getAllFileWithPath() {
    const files = this.vault.getFiles();
    const allFileWithPath = [];
    const shareKey = this.settings.shareKey;
    for (const file of files) {
      if (isAttachment(file.extension)) {
        const filepath = getImageLinkOptions(file, this.settings, null);
        allFileWithPath.push({
          converted: filepath,
          real: file.path
        });
      } else if (file.extension == "md") {
        const frontMatter = this.metadataCache.getCache(file.path).frontmatter;
        if (frontMatter && frontMatter[shareKey] === true) {
          const filepath = getReceiptFolder(file, this.settings, this.metadataCache, this.vault);
          allFileWithPath.push({
            converted: filepath,
            real: file.path,
            repoFrontmatter: getRepoFrontmatter(this.settings, frontMatter)
          });
        }
      }
    }
    return allFileWithPath;
  }
  getLinkedByEmbedding(file) {
    const linkedFiles = this.getLinkedFiles(file);
    const imageEmbedded = this.metadataCache.getFileCache(file).embeds;
    if (imageEmbedded != void 0) {
      for (const image of imageEmbedded) {
        try {
          const imageLink = this.metadataCache.getFirstLinkpathDest(image.link.replace(/#.*/, ""), file.path);
          if (imageLink !== null) {
            if (imageLink.extension === "md") {
              const checkFrontmatter = this.metadataCache.getCache(imageLink.path).frontmatter;
              if (checkFrontmatter && checkFrontmatter[this.settings.shareKey] === true) {
                linkedFiles.push({
                  linked: imageLink,
                  linkFrom: image.link,
                  altText: image.displayText
                });
              }
            } else {
              linkedFiles.push({
                linked: imageLink,
                linkFrom: image.link,
                altText: image.displayText
              });
            }
          }
        } catch (e) {
        }
      }
    }
    return [...new Set(linkedFiles)];
  }
  getLinkedFiles(file) {
    const embedCaches = this.metadataCache.getCache(file.path).links;
    const embedList = [];
    if (embedCaches != void 0) {
      for (const embedCache of embedCaches) {
        try {
          const linkedFile = this.metadataCache.getFirstLinkpathDest(embedCache.link, file.path);
          if (linkedFile) {
            const frontmatter = this.metadataCache.getCache(linkedFile.path).frontmatter;
            let frontmatterDestinationFilePath;
            if (frontmatter) {
              frontmatterDestinationFilePath = frontmatter.filename;
            }
            embedList.push({
              linked: linkedFile,
              linkFrom: embedCache.link,
              altText: embedCache.displayText,
              destinationFilePath: frontmatterDestinationFilePath
            });
          }
        } catch (e) {
          noticeLog(e, this.settings);
          noticeLog("Error with this links : " + embedCache.link, this.settings);
        }
      }
      return [...new Set(embedList)];
    }
    return [];
  }
  getSharedEmbed(file, frontmatterSourceFile) {
    const embedCaches = this.metadataCache.getCache(file.path).embeds;
    const imageList = [];
    if (embedCaches != void 0) {
      for (const embed of embedCaches) {
        try {
          const imageLink = this.metadataCache.getFirstLinkpathDest(embed.link.replace(/#(.*)/, ""), file.path);
          imageList.push(this.imageSharedOrNote(imageLink, frontmatterSourceFile));
        } catch (e) {
          noticeLog(e, this.settings);
          noticeLog("Error with this file : " + embed.displayText, this.settings);
        }
      }
      return [...new Set(imageList)].filter((x) => x !== null);
    }
    return [];
  }
  checkExcludedFolder(file) {
    const excludedFolder = this.settings.ExcludedFolder.split(",").filter((x) => x != "");
    if (excludedFolder.length > 0) {
      for (let i = 0; i < excludedFolder.length; i++) {
        if (file.path.contains(excludedFolder[i].trim())) {
          return true;
        }
      }
    }
    return false;
  }
  getLastEditedTimeRepo(octokit, githubRepo, settings2) {
    return __async(this, null, function* () {
      const commits = yield octokit.request("GET /repos/{owner}/{repo}/commits", {
        owner: settings2.githubName,
        repo: settings2.githubRepo,
        path: githubRepo.file
      });
      const lastCommittedFile = commits.data[0];
      return new Date(lastCommittedFile.commit.committer.date);
    });
  }
  getAllFileFromRepo(ref = "main", octokit, settings2, repo) {
    return __async(this, null, function* () {
      const filesInRepo = [];
      try {
        const repoContents = yield octokit.request("GET /repos/{owner}/{repo}/git/trees/{tree_sha}", {
          owner: repo.owner,
          repo: repo.repo,
          tree_sha: ref,
          recursive: "true"
        });
        if (repoContents.status === 200) {
          const files = repoContents.data.tree;
          for (const file of files) {
            const basename = (name) => /([^/\\.]*)(\..*)?$/.exec(name)[1];
            if (file.type === "blob" && basename(file.path).length > 0) {
              filesInRepo.push({
                file: file.path,
                sha: file.sha
              });
            }
          }
        }
      } catch (e) {
        noticeLog(e, settings2);
      }
      return filesInRepo;
    });
  }
  getNewFiles(allFileWithPath, githubSharedFiles, vault) {
    const newFiles = [];
    for (const file of allFileWithPath) {
      if (!githubSharedFiles.some((x) => x.file === file.converted.trim())) {
        const fileInVault = vault.getAbstractFileByPath(file.real.trim());
        if (fileInVault && fileInVault instanceof import_obsidian8.TFile && fileInVault.extension === "md") {
          newFiles.push(fileInVault);
        }
      }
    }
    return newFiles;
  }
  getImageByPath(path, field, frontmatterSourceFile) {
    if (field.constructor.name === "Link") {
      field = field.path;
    }
    if (path.constructor.name === "Link") {
      path = path.path;
    }
    const imageLink = this.metadataCache.getFirstLinkpathDest(field, path);
    if (imageLink !== null) {
      return this.imageSharedOrNote(imageLink, frontmatterSourceFile);
    }
    return null;
  }
  imageSharedOrNote(file, settingsConversion) {
    const transferImage = settingsConversion.attachment;
    const transferEmbeds = settingsConversion.embed;
    if (isAttachment(file.extension) && transferImage || transferEmbeds && file.extension === "md") {
      return file;
    }
    return null;
  }
  getMetadataLinks(file, embedFiles, frontmatterSourceFile, frontmatterSettings) {
    return __async(this, null, function* () {
      for (const field of this.settings.metadataFileFields) {
        if (frontmatterSourceFile[field] != void 0) {
          const imageLink = this.metadataCache.getFirstLinkpathDest(frontmatterSourceFile[field], file.path);
          if (imageLink !== null) {
            embedFiles.push(this.imageSharedOrNote(file, frontmatterSettings));
          }
        }
      }
      if (this.plugin.app.plugins.enabledPlugins.has("dataview")) {
        const dvApi = (0, import_obsidian_dataview2.getAPI)();
        const dataviewMetadata = yield dvApi.page(file.path);
        for (const field of this.settings.metadataFileFields) {
          const fieldValue = dataviewMetadata[field];
          if (fieldValue != void 0) {
            if (fieldValue.constructor.name === "Array") {
              for (const value of fieldValue) {
                embedFiles.push(this.getImageByPath(value, fieldValue, frontmatterSettings));
              }
            } else {
              embedFiles.push(this.getImageByPath(fieldValue, fieldValue, frontmatterSettings));
            }
          }
        }
      }
      return [...new Set(embedFiles)].filter((x) => x != null);
    });
  }
  getEditedFiles(allFileWithPath, githubSharedFiles, vault, newFiles) {
    return __async(this, null, function* () {
      for (const file of allFileWithPath) {
        if (githubSharedFiles.some((x) => x.file === file.converted.trim())) {
          const githubSharedFile = githubSharedFiles.find((x) => x.file === file.converted.trim());
          const repoEditedTime = yield this.getLastEditedTimeRepo(this.octokit, githubSharedFile, this.settings);
          const fileInVault = vault.getAbstractFileByPath(file.real.trim());
          if (fileInVault && fileInVault instanceof import_obsidian8.TFile && fileInVault.extension === "md") {
            const vaultEditedTime = new Date(fileInVault.stat.mtime);
            if (vaultEditedTime > repoEditedTime) {
              noticeLog(`edited file : ${fileInVault.path} / ${vaultEditedTime} vs ${repoEditedTime}`, this.settings);
              newFiles.push(fileInVault);
            }
          }
        }
      }
      return newFiles;
    });
  }
};

// plugin/publishing/branch.ts
var import_obsidian9 = require("obsidian");
var GithubBranch = class extends FilesManagement {
  constructor(settings2, octokit, vault, metadataCache, plugin) {
    super(vault, metadataCache, settings2, octokit, plugin);
    this.settings = settings2;
    this.octokit = octokit;
    this.plugin = plugin;
  }
  newBranch(branchName, repoFrontmatter) {
    return __async(this, null, function* () {
      if (repoFrontmatter instanceof Array) {
        for (const repo of repoFrontmatter) {
          yield this.newBranchOnRepo(branchName, repo);
        }
      } else {
        yield this.newBranchOnRepo(branchName, repoFrontmatter);
      }
    });
  }
  newBranchOnRepo(branchName, repoFrontmatter) {
    return __async(this, null, function* () {
      const allBranch = yield this.octokit.request("GET /repos/{owner}/{repo}/branches", {
        owner: repoFrontmatter.owner,
        repo: repoFrontmatter.repo
      });
      const mainBranch = allBranch.data.find((branch) => branch.name === repoFrontmatter.branch);
      const shaMainBranch = mainBranch.commit.sha;
      try {
        const branch = yield this.octokit.request("POST /repos/{owner}/{repo}/git/refs", {
          owner: repoFrontmatter.owner,
          repo: repoFrontmatter.repo,
          ref: "refs/heads/" + branchName,
          sha: shaMainBranch
        });
        console.log("branch successfully created", branch.status, " for : ", repoFrontmatter.repo);
        return branch.status === 201;
      } catch (e) {
        console.log(e);
        const allBranch2 = yield this.octokit.request("GET /repos/{owner}/{repo}/branches", {
          owner: repoFrontmatter.owner,
          repo: repoFrontmatter.repo
        });
        const mainBranch2 = allBranch2.data.find((branch) => branch.name === branchName);
        return !!mainBranch2;
      }
    });
  }
  pullRequestOnRepo(branchName, repoFrontmatter) {
    return __async(this, null, function* () {
      try {
        const PR = yield this.octokit.request("POST /repos/{owner}/{repo}/pulls", {
          owner: repoFrontmatter.owner,
          repo: repoFrontmatter.repo,
          title: `PullRequest ${branchName} from Obsidian`,
          body: "",
          head: branchName,
          base: repoFrontmatter.branch
        });
        return PR.data.number;
      } catch (e) {
        console.log(e);
        try {
          const PR = yield this.octokit.request("GET /repos/{owner}/{repo}/pulls", {
            owner: repoFrontmatter.owner,
            repo: repoFrontmatter.repo,
            state: "open"
          });
          return PR.data[0].number;
        } catch (e2) {
          console.log(e2, "error", repoFrontmatter);
          return false;
        }
      }
    });
  }
  deleteBranchOnRepo(branchName, repoFrontmatter) {
    return __async(this, null, function* () {
      try {
        const branch = yield this.octokit.request("DELETE /repos/{owner}/{repo}/git/refs/heads/" + branchName, {
          owner: repoFrontmatter.owner,
          repo: repoFrontmatter.repo
        });
        return branch.status === 200;
      } catch (e) {
        return false;
      }
    });
  }
  mergePullRequestOnRepo(branchName, silent = false, pullRequestNumber, repoFrontmatter) {
    return __async(this, null, function* () {
      try {
        const branch = yield this.octokit.request("PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge", {
          owner: repoFrontmatter.owner,
          repo: repoFrontmatter.repo,
          pull_number: pullRequestNumber,
          commit_title: `[PUBLISHER] Merge #${pullRequestNumber}`,
          merge_method: "squash"
        });
        return branch.status === 200;
      } catch (e) {
        console.log(e);
        new import_obsidian9.Notice(error("mergeconflic"));
        return false;
      }
    });
  }
  updateRepository(branchName, repoFrontmatter) {
    return __async(this, null, function* () {
      if (repoFrontmatter instanceof Array) {
        const success = [];
        for (const repo of repoFrontmatter) {
          success.push(yield this.updateRepositoryOnOne(branchName, repo));
        }
        return !success.every((value) => value === false);
      } else {
        return yield this.updateRepositoryOnOne(branchName, repoFrontmatter);
      }
    });
  }
  updateRepositoryOnOne(branchName, repoFrontmatter) {
    return __async(this, null, function* () {
      try {
        const pullRequest = yield this.pullRequestOnRepo(branchName, repoFrontmatter);
        if (this.settings.automaticallyMergePR) {
          const PRSuccess = yield this.mergePullRequestOnRepo(branchName, true, pullRequest, repoFrontmatter);
          if (PRSuccess) {
            yield this.deleteBranchOnRepo(branchName, repoFrontmatter);
            return true;
          }
          return false;
        }
        return true;
      } catch (e) {
        console.log(e);
        new import_obsidian9.Notice(error("errorConfig")(`${repoFrontmatter.owner}/${repoFrontmatter.repo}`));
        return false;
      }
    });
  }
};

// node_modules/universal-user-agent/dist-web/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/core/dist-web/index.js
var import_before_after_hook = __toESM(require_before_after_hook());

// node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  var ctor, prot;
  if (isObject(o) === false)
    return false;
  ctor = o.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/@octokit/endpoint/dist-web/index.js
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (defaults && defaults.mediaType.previews.length) {
    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
  }
  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  return Object.keys(object).filter((option) => !keysToOmit.includes(option)).reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
}
function parse(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (options.mediaType.previews.length) {
      const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
        const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
        return `application/vnd.github.${preview}-preview${format}`;
      }).join(",");
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      } else {
        headers["content-length"] = 0;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var VERSION2 = "6.0.12";
var userAgent = `octokit-endpoint.js/${VERSION2} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: "",
    previews: []
  }
};
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/dist-web/index.js
var import_node_fetch = __toESM(require_browser());

// node_modules/deprecation/dist-web/index.js
var Deprecation = class extends Error {
  constructor(message) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "Deprecation";
  }
};

// node_modules/@octokit/request-error/dist-web/index.js
var import_once = __toESM(require_once());
var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(new Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(new Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
        return headers || {};
      }
    });
  }
};

// node_modules/@octokit/request/dist-web/index.js
var VERSION3 = "5.6.3";
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  const fetch = requestOptions.request && requestOptions.request.fetch || import_node_fetch.default;
  return fetch(requestOptions.url, Object.assign({
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    redirect: requestOptions.redirect
  }, requestOptions.request)).then((response) => __async(this, null, function* () {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: yield getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = yield getResponseData(response);
      const error2 = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error2;
    }
    return getResponseData(response);
  })).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error2) => {
    if (error2 instanceof RequestError)
      throw error2;
    throw new RequestError(error2.message, 500, {
      request: requestOptions
    });
  });
}
function getResponseData(response) {
  return __async(this, null, function* () {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
      return response.json();
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
      return response.text();
    }
    return getBufferResponse(response);
  });
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
    }
    return data.message;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION3} ${getUserAgent()}`
  }
});

// node_modules/@octokit/graphql/dist-web/index.js
var VERSION4 = "4.8.0";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.name = "GraphqlResponseError";
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }
    return response.data.data;
  });
}
function withDefaults3(request$1, newDefaults) {
  const newRequest = request$1.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: request.endpoint
  });
}
var graphql$1 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION4} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-web/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
function auth(token) {
  return __async(this, null, function* () {
    const isApp = token.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
    return {
      type: "token",
      token,
      tokenType
    };
  });
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
function hook(token, request2, route, parameters) {
  return __async(this, null, function* () {
    const endpoint2 = request2.endpoint.merge(route, parameters);
    endpoint2.headers.authorization = withAuthorizationPrefix(token);
    return request2(endpoint2);
  });
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-web/index.js
var VERSION5 = "3.6.0";
var Octokit = class {
  constructor(options = {}) {
    const hook2 = new import_before_after_hook.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = [
      options.userAgent,
      `octokit-core.js/${VERSION5} ${getUserAgent()}`
    ].filter(Boolean).join(" ");
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign({
      debug: () => {
      },
      info: () => {
      },
      warn: console.warn.bind(console),
      error: console.error.bind(console)
    }, options.log);
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = () => __async(this, null, function* () {
          return {
            type: "unauthenticated"
          };
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const _a = options, { authStrategy } = _a, otherOptions = __objRest(_a, ["authStrategy"]);
      const auth2 = authStrategy(Object.assign({
        request: this.request,
        log: this.log,
        octokit: this,
        octokitOptions: otherOptions
      }, options.auth));
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    classConstructor.plugins.forEach((plugin) => {
      Object.assign(this, plugin(this, options));
    });
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
          userAgent: `${options.userAgent} ${defaults.userAgent}`
        } : null));
      }
    };
    return OctokitWithDefaults;
  }
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))), _a);
    return NewOctokit;
  }
};
Octokit.VERSION = VERSION5;
Octokit.plugins = [];

// plugin/commands.ts
var import_obsidian10 = require("obsidian");
function shareAllMarkedNotes(PublisherManager, settings2, octokit, statusBarItems, branchName, repoFrontmatter, sharedFiles, createGithubBranch = true) {
  return __async(this, null, function* () {
    const statusBar = new ShareStatusBar(statusBarItems, sharedFiles.length);
    try {
      let errorCount = 0;
      if (sharedFiles.length > 0) {
        const publishedFiles = sharedFiles.map((file) => file.name);
        if (createGithubBranch) {
          yield PublisherManager.newBranch(branchName, repoFrontmatter);
        }
        for (let files = 0; files < sharedFiles.length; files++) {
          try {
            const file = sharedFiles[files];
            statusBar.increment();
            yield PublisherManager.publish(file, false, branchName, repoFrontmatter);
          } catch (e) {
            errorCount++;
            new import_obsidian10.Notice(error("unablePublishNote")(sharedFiles[files].name));
          }
        }
        statusBar.finish(8e3);
        const noticeValue = `${publishedFiles.length - errorCount} notes`;
        yield deleteFromGithub(true, settings2, octokit, branchName, PublisherManager, repoFrontmatter);
        const update = yield PublisherManager.updateRepository(branchName, repoFrontmatter);
        if (update) {
          yield noticeMessage(PublisherManager, noticeValue, settings2, repoFrontmatter);
        } else {
          new import_obsidian10.Notice(error("errorPublish")(settings2.githubRepo));
        }
      }
    } catch (error2) {
      console.error(error2);
      new import_obsidian10.Notice(error2("unablePublishMultiNotes"));
      statusBar.error();
    }
  });
}
function deleteUnsharedDeletedNotes(PublisherManager, settings2, octokit, branchName, repoFrontmatter) {
  return __async(this, null, function* () {
    try {
      new import_obsidian10.Notice(informations("startingClean")(settings2.githubRepo));
      yield PublisherManager.newBranch(branchName, repoFrontmatter);
      yield deleteFromGithub(false, settings2, octokit, branchName, PublisherManager, repoFrontmatter);
      yield PublisherManager.updateRepository(branchName, repoFrontmatter);
    } catch (e) {
      console.error(e);
    }
  });
}
function shareOneNote(branchName, PublisherManager, settings2, file, metadataCache, vault) {
  return __async(this, null, function* () {
    try {
      const frontmatter = metadataCache.getFileCache(file).frontmatter;
      const repoFrontmatter = getRepoFrontmatter(settings2, frontmatter);
      yield PublisherManager.newBranch(branchName, repoFrontmatter);
      const publishSuccess = yield PublisherManager.publish(file, true, branchName, repoFrontmatter, [], true);
      if (publishSuccess) {
        const update = yield PublisherManager.updateRepository(branchName, repoFrontmatter);
        if (update) {
          yield noticeMessage(PublisherManager, file, settings2, repoFrontmatter);
          yield createLink(file, repoFrontmatter, metadataCache, vault, settings2);
        } else {
          new import_obsidian10.Notice(error("errorPublish")(settings2.githubRepo));
        }
      }
    } catch (error2) {
      if (!(error2 instanceof DOMException)) {
        console.error(error2);
        new import_obsidian10.Notice(error2("errorPublish")(settings2.githubRepo));
      }
    }
  });
}
function shareNewNote(PublisherManager, octokit, branchName, vault, plugin, repoFrontmatter) {
  return __async(this, null, function* () {
    const settings2 = plugin.settings;
    new import_obsidian10.Notice(informations("scanningRepo"));
    const branchMaster = settings2.githubBranch;
    const sharedFilesWithPaths = PublisherManager.getAllFileWithPath();
    const githubSharedNotes = yield PublisherManager.getAllFileFromRepo(branchMaster, octokit, settings2, repoFrontmatter);
    const newlySharedNotes = PublisherManager.getNewFiles(sharedFilesWithPaths, githubSharedNotes, vault);
    if (newlySharedNotes.length > 0) {
      new import_obsidian10.Notice(informations("foundNoteToSend")(`${newlySharedNotes.length}`));
      const statusBarElement = plugin.addStatusBarItem();
      yield PublisherManager.newBranch(branchName, repoFrontmatter);
      yield shareAllMarkedNotes(PublisherManager, plugin.settings, octokit, statusBarElement, branchName, repoFrontmatter, newlySharedNotes);
    } else {
      new import_obsidian10.Notice(informations("noNewNote"));
    }
  });
}
function shareAllEditedNotes(PublisherManager, octokit, branchName, vault, plugin, repoFrontmatter) {
  return __async(this, null, function* () {
    const settings2 = plugin.settings;
    new import_obsidian10.Notice(informations("scanningRepo"));
    const branchMaster = settings2.githubBranch;
    const sharedFilesWithPaths = PublisherManager.getAllFileWithPath();
    const githubSharedNotes = yield PublisherManager.getAllFileFromRepo(branchMaster, octokit, settings2, repoFrontmatter);
    const newSharedFiles = PublisherManager.getNewFiles(sharedFilesWithPaths, githubSharedNotes, vault);
    const newlySharedNotes = yield PublisherManager.getEditedFiles(sharedFilesWithPaths, githubSharedNotes, vault, newSharedFiles);
    if (newlySharedNotes.length > 0) {
      new import_obsidian10.Notice(informations("foundNoteToSend")(`${newlySharedNotes.length}`));
      const statusBarElement = plugin.addStatusBarItem();
      yield PublisherManager.newBranch(branchName, repoFrontmatter);
      yield shareAllMarkedNotes(PublisherManager, settings2, octokit, statusBarElement, branchName, repoFrontmatter, newlySharedNotes);
    } else {
      new import_obsidian10.Notice(informations("noNewNote"));
    }
  });
}
function shareOnlyEdited(PublisherManager, octokit, branchName, vault, plugin, repoFrontmatter) {
  return __async(this, null, function* () {
    const settings2 = plugin.settings;
    new import_obsidian10.Notice(informations("scanningRepo"));
    const branchMaster = settings2.githubBranch;
    const sharedFilesWithPaths = PublisherManager.getAllFileWithPath();
    const githubSharedNotes = yield PublisherManager.getAllFileFromRepo(branchMaster, octokit, settings2, repoFrontmatter);
    const newSharedFiles = [];
    const newlySharedNotes = yield PublisherManager.getEditedFiles(sharedFilesWithPaths, githubSharedNotes, vault, newSharedFiles);
    if (newlySharedNotes.length > 0) {
      new import_obsidian10.Notice(informations("foundNoteToSend")(`${newlySharedNotes.length}`));
      const statusBarElement = plugin.addStatusBarItem();
      yield PublisherManager.newBranch(branchName, repoFrontmatter);
      yield shareAllMarkedNotes(PublisherManager, settings2, octokit, statusBarElement, branchName, repoFrontmatter, newlySharedNotes);
    } else {
      new import_obsidian10.Notice(informations("noNewNote"));
    }
  });
}

// plugin/main.ts
var GithubPublisher = class extends import_obsidian11.Plugin {
  onload() {
    return __async(this, null, function* () {
      console.log("Github Publisher loaded");
      yield this.loadSettings();
      this.addSettingTab(new GithubPublisherSettings(this.app, this));
      const convertOldSettings = () => __async(this, null, function* () {
        const oldExcludedSettings = this.settings.autoCleanUpExcluded;
        if (typeof oldExcludedSettings === "string") {
          this.settings.autoCleanUpExcluded = oldExcludedSettings === "" ? [] : oldExcludedSettings.split(/[,\n]\W*/);
          yield this.saveSettings();
        }
        this.settings.autoCleanUpExcluded = this.settings.autoCleanUpExcluded.filter((e) => e !== "");
        yield this.saveSettings();
      });
      convertOldSettings().then();
      const octokit = new Octokit({ auth: this.settings.GhToken });
      const PublisherManager = new GithubBranch(this.settings, octokit, this.app.vault, this.app.metadataCache, this);
      const branchName = app.vault.getName().replaceAll(" ", "-").replaceAll(".", "-") + "-" + new Date().toLocaleDateString("en-US").replace(/\//g, "-");
      const repo = getRepoFrontmatter(this.settings);
      this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
        if (disablePublish(this.app, this.settings, file) && this.settings.fileMenu) {
          menu.addItem((item) => {
            item.setSection("action");
            item.setTitle(commands("shareViewFiles")(file.basename)).setIcon("share").onClick(() => __async(this, null, function* () {
              yield shareOneNote(branchName, PublisherManager, this.settings, file, this.app.metadataCache, this.app.vault);
            }));
          });
          menu.addSeparator();
        }
      }));
      this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
        if (disablePublish(this.app, this.settings, view.file) && this.settings.editorMenu) {
          menu.addSeparator();
          menu.addItem((item) => {
            item.setSection("mkdocs-publisher");
            item.setTitle(commands("shareViewFiles")(view.file.basename)).setIcon("share").onClick(() => __async(this, null, function* () {
              yield shareOneNote(branchName, PublisherManager, this.settings, view.file, this.app.metadataCache, this.app.vault);
            }));
          });
        }
      }));
      if (this.settings.shareExternalModified) {
        this.registerEvent(this.app.vault.on("modify", (file) => __async(this, null, function* () {
          if (file !== this.app.workspace.getActiveFile()) {
            const isShared = this.app.metadataCache.getFileCache(file).frontmatter ? this.app.metadataCache.getFileCache(file).frontmatter[this.settings.shareKey] : false;
            if (isShared) {
              yield shareOneNote(branchName, PublisherManager, this.settings, file, this.app.metadataCache, this.app.vault);
            }
          }
        })));
      }
      this.addCommand({
        id: "publisher-one",
        name: commands("shareActiveFile"),
        hotkeys: [],
        checkCallback: (checking) => {
          if (disablePublish(this.app, this.settings, this.app.workspace.getActiveFile())) {
            if (!checking) {
              shareOneNote(branchName, PublisherManager, this.settings, this.app.workspace.getActiveFile(), this.app.metadataCache, this.app.vault);
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "publisher-delete-clean",
        name: commands("publisherDeleteClean"),
        hotkeys: [],
        checkCallback: (checking) => {
          if (this.settings.autoCleanUp) {
            if (!checking) {
              deleteUnsharedDeletedNotes(PublisherManager, this.settings, octokit, branchName, repo);
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "publisher-publish-all",
        name: commands("uploadAllNotes"),
        callback: () => __async(this, null, function* () {
          const sharedFiles = PublisherManager.getSharedFiles();
          const statusBarItems = this.addStatusBarItem();
          yield shareAllMarkedNotes(PublisherManager, this.settings, octokit, statusBarItems, branchName, repo, sharedFiles, true);
        })
      });
      this.addCommand({
        id: "publisher-upload-new",
        name: commands("uploadNewNotes"),
        callback: () => __async(this, null, function* () {
          yield shareNewNote(PublisherManager, octokit, branchName, this.app.vault, this, repo);
        })
      });
      this.addCommand({
        id: "publisher-upload-all-edited-new",
        name: commands("uploadAllNewEditedNote"),
        callback: () => __async(this, null, function* () {
          yield shareAllEditedNotes(PublisherManager, octokit, branchName, this.app.vault, this, repo);
        })
      });
      this.addCommand({
        id: "publisher-upload-edited",
        name: commands("uploadAllEditedNote"),
        callback: () => __async(this, null, function* () {
          yield shareOnlyEdited(PublisherManager, octokit, branchName, this.app.vault, this, repo);
        })
      });
    });
  }
  onunload() {
    console.log("Github Publisher unloaded");
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
